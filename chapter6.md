第6章 ファイルシステム
=====================

ファイルシステムの目的は、データを構成し保存することである。
ファイルシステムは典型的に、ユーザおよびアプリケーション間でデータを共有し、「維持する」ということである。
従って、ファイルはコンピュータを再起動しても存在し続ける。

xv6のファイルシステムはUNIXライクなものを提供しており、ファイル、ディレクトリ、パス名(第0章を参照のこと)をサポートし、IDEディスクに保存することいによって永続性を確保することができる(第3章を参照)。
ファイルシステムはいくつかの困難を解決する必要がある。

* ファイルシステムはツリー構成のディレクトリおよびファイルを表現するためのデータ構造をディスク上に構築する必要がある。また各ファイルの内容を保持するための識別子と、どのディスクエリアがフリーであるかの情報を保持しておく必要がある。
* ファイルシステムは「クラッシュからのリカバリ」をサポートする必要がある。つまり、もしクラッシュが発生しても(例えば、電源遮断など)、再起動後にファイルシステムは正しく動作する必要がある。
クラッシュのリスクは、データの更新の歳に割り込みが発生し、ディスク上のデータの一貫性に影響が出ことである(例えば、ファイルが存在することと、フリー状態であることを示すブロックのマークなど)。
* 異なるプロセがファイルシステムを同時に扱うため、不変性を維持するためにこれらの操作の更新をする必要がある。
* ディスクへのアクセスはメモリへのアクセスに比べて格段に遅く、従ってファイルシステムは頻繁に利用されるブロックについてメモリ上にキャッシュする仕組みを提供する必要がある。

本章では、上記の困難をxv6ではどのように解決しているかについて説明する。

# 概要

xv6のファイルシステムは図6-1に示すように7つのレイヤで構成されている。
ディスクレイヤは、IDEハードドライブのブロックを読み書きする。
バッファキャッシュレイヤはディスクブロックをキャッシュし、ブロックのアクセスの同期を取り、データが格納されている特定のブロックについて、たった一つのブロックのみが変更を行っていることを保証する。
ロギングレイヤは高位のレイヤのいくつかのブロックの更新操作を「トランザクション」としてラップし、またクラッシュが発生した場合でも、ブロックがアトミックに更新されたことを保証する(例えば、全てのブロックがアップデートされたか、または一つもアップデートされていないか)。
inodeレイヤは個々のファイルを提供し、それぞれのノードはinodeというユニークなi-numberと、ファイルを保持しているいくつかのブロックで構成される。
ディレクトリレイヤはいくつかのディレクトリを構成し、特別な種類のi-nodeとして構成さえる。
ディレクトリのinodeはディレクトリのエントリ列が含まれており、各エントリにはファイル名とi-numberが入っている。
パス名レイヤは、/usr/rtm/xv6/fs.cのような階層的なパス構成を提供し、階層的な探索によりそれを解決する。
ファイルディスクリプタレイヤは多くのUNIXの資源を抽象化する(例えば、パイプやデバイス、ファイルなど)。
これにはファイルシステムインタフェースを用い、これによりアプリケーションプログラマのプログラミングを簡単化する。

ファイルシステムはinodeをどこに格納して、デキスクのどこのブロックに内容を格納するかについての方針を決める必要がある。
これを行うためには、xv6は、図6-2に示すようにディスクをいくつかのセクションに分割する。
ファイルシステムはブロック0は使用しない(これはブートセクタを保持している)。
ブロック1は「スーパブロック」と呼ばれ、ファイルシステムのメタデータを格納している(ブロックのファイルサイズ、データブロックの数、inodeの数、ログ中のブロックの数).
ブロック2以降はinodeを保持しており、ブロックあたりに複数のinodeを保持している。
データブロックを辿っていたビットマップのブロックは、使用中である。
殆どの残りのブロックは、データブロックである; それぞれのブロックはビットマップブロック上でフリーであることをマークされており、ファイルもしくはディレクトリが保持されている。
ディスクの最後のブロックはロギングレイヤのログが格納されている。

本章の以降では、各レイヤについて議論する。まずはバッファキャッシュのレイヤから始まり、うまく選択された下位レイヤの抽象化により、上位のレイヤがより易しくなっていることを見ていこう。

# バッファキャシュレイヤ

バッファキャッシュレイヤの仕事は2つある: (1)ディスクブロックのアクセスの同期を行い、たった一つのブロックのコピーがメモリ中に存在し、たった一つのカーネルスレッドがそのコピーを使っていることを保証する;
(2)頻繁に利用するブロックをキャッシュし、低速なディスクから何度も読み出す必要を無くす。コードはbio.cに実装されている。

バッファキャッシュのためにエクスポートされた主のインタフェースは、breadとbwriteである; 前者はメモリにコピーされた、読み書き可能なブロックの内容のコピーを取得し、
後者は更新されたバッファをディスクの適切なブロックに書き込む。
カーネルスレッドは、書き込みが完了したときはbrelseを呼び出して、バッファを解放しなければならない。

バッファキャシュは各ブロックを同期化し、各ブロックが、最大でも1つのカーネルスレッドがブロックのバッファを参照していることを許可する。
もし1つのカーネルスレッドがバッファを参照しており、それを解放していなければ、他のスレッドがbreadを呼び出して同一のバッファを参照しようとしているとき、それは待たされる。
より高位のファイルシステムレイヤはバッファキャッシュブロックの同期により、不変性が保たれることを支援している。

バッファキャッシュはディスクブロックを保持するための固定数のバッファを持っており、ファイルシステムがキャッシュ上に存在していないブロックを妖精した場合は、
バッファキャッシュは現在保持しているバッファと交換して、バッファをリサイクルしなければならない。
バッファキャッシュは最も最近利用されていないバッファに新しいブロックを挿入する。
最も利用されていないバッファは、今後最も利用されないブロックであるという仮定に基いている。
