第6章 ファイルシステム
=====================

ファイルシステムの目的は、データを構成し保存することである。
ファイルシステムは典型的に、ユーザおよびアプリケーション間でデータを共有し、「維持する」ということである。
従って、ファイルはコンピュータを再起動しても存在し続ける。

xv6のファイルシステムはUNIXライクなものを提供しており、ファイル、ディレクトリ、パス名(第0章を参照のこと)をサポートし、IDEディスクに保存することいによって永続性を確保することができる(第3章を参照)。
ファイルシステムはいくつかの困難を解決する必要がある。

* ファイルシステムはツリー構成のディレクトリおよびファイルを表現するためのデータ構造をディスク上に構築する必要がある。また各ファイルの内容を保持するための識別子と、どのディスクエリアがフリーであるかの情報を保持しておく必要がある。
* ファイルシステムは「クラッシュからのリカバリ」をサポートする必要がある。つまり、もしクラッシュが発生しても(例えば、電源遮断など)、再起動後にファイルシステムは正しく動作する必要がある。
クラッシュのリスクは、データの更新の歳に割り込みが発生し、ディスク上のデータの一貫性に影響が出ことである(例えば、ファイルが存在することと、フリー状態であることを示すブロックのマークなど)。
* 異なるプロセがファイルシステムを同時に扱うため、不変性を維持するためにこれらの操作の更新をする必要がある。
* ディスクへのアクセスはメモリへのアクセスに比べて格段に遅く、従ってファイルシステムは頻繁に利用されるブロックについてメモリ上にキャッシュする仕組みを提供する必要がある。

本章では、上記の困難をxv6ではどのように解決しているかについて説明する。

# 概要

xv6のファイルシステムは図6-1に示すように7つのレイヤで構成されている。
ディスクレイヤは、IDEハードドライブのブロックを読み書きする。
バッファキャッシュレイヤはディスクブロックをキャッシュし、ブロックのアクセスの同期を取り、データが格納されている特定のブロックについて、たった一つのブロックのみが変更を行っていることを保証する。
ロギングレイヤは高位のレイヤのいくつかのブロックの更新操作を「トランザクション」としてラップし、またクラッシュが発生した場合でも、ブロックがアトミックに更新されたことを保証する(例えば、全てのブロックがアップデートされたか、または一つもアップデートされていないか)。
inodeレイヤは個々のファイルを提供し、それぞれのノードはinodeというユニークなi-numberと、ファイルを保持しているいくつかのブロックで構成される。
ディレクトリレイヤはいくつかのディレクトリを構成し、特別な種類のi-nodeとして構成さえる。
ディレクトリのinodeはディレクトリのエントリ列が含まれており、各エントリにはファイル名とi-numberが入っている。
パス名レイヤは、/usr/rtm/xv6/fs.cのような階層的なパス構成を提供し、階層的な探索によりそれを解決する。
ファイルディスクリプタレイヤは多くのUNIXの資源を抽象化する(例えば、パイプやデバイス、ファイルなど)。
これにはファイルシステムインタフェースを用い、これによりアプリケーションプログラマのプログラミングを簡単化する。

ファイルシステムはinodeをどこに格納して、デキスクのどこのブロックに内容を格納するかについての方針を決める必要がある。
これを行うためには、xv6は、図6-2に示すようにディスクをいくつかのセクションに分割する。
ファイルシステムはブロック0は使用しない(これはブートセクタを保持している)。
ブロック1は「スーパブロック」と呼ばれ、ファイルシステムのメタデータを格納している(ブロックのファイルサイズ、データブロックの数、inodeの数、ログ中のブロックの数).
ブロック2以降はinodeを保持しており、ブロックあたりに複数のinodeを保持している。
データブロックを辿っていたビットマップのブロックは、使用中である。
殆どの残りのブロックは、データブロックである; それぞれのブロックはビットマップブロック上でフリーであることをマークされており、ファイルもしくはディレクトリが保持されている。
ディスクの最後のブロックはロギングレイヤのログが格納されている。

本章の以降では、各レイヤについて議論する。まずはバッファキャッシュのレイヤから始まり、うまく選択された下位レイヤの抽象化により、上位のレイヤがより易しくなっていることを見ていこう。

# バッファキャシュレイヤ

バッファキャッシュレイヤの仕事は2つある: (1)ディスクブロックのアクセスの同期を行い、たった一つのブロックのコピーがメモリ中に存在し、たった一つのカーネルスレッドがそのコピーを使っていることを保証する;
(2)頻繁に利用するブロックをキャッシュし、低速なディスクから何度も読み出す必要を無くす。コードはbio.cに実装されている。

バッファキャッシュのためにエクスポートされた主のインタフェースは、breadとbwriteである; 前者はメモリにコピーされた、読み書き可能なブロックの内容のコピーを取得し、
後者は更新されたバッファをディスクの適切なブロックに書き込む。
カーネルスレッドは、書き込みが完了したときはbrelseを呼び出して、バッファを解放しなければならない。

バッファキャシュは各ブロックを同期化し、各ブロックが、最大でも1つのカーネルスレッドがブロックのバッファを参照していることを許可する。
もし1つのカーネルスレッドがバッファを参照しており、それを解放していなければ、他のスレッドがbreadを呼び出して同一のバッファを参照しようとしているとき、それは待たされる。
より高位のファイルシステムレイヤはバッファキャッシュブロックの同期により、不変性が保たれることを支援している。

バッファキャッシュはディスクブロックを保持するための固定数のバッファを持っており、ファイルシステムがキャッシュ上に存在していないブロックを妖精した場合は、
バッファキャッシュは現在保持しているバッファと交換して、バッファをリサイクルしなければならない。
バッファキャッシュは最も最近利用されていないバッファに新しいブロックを挿入する。
最も利用されていないバッファは、今後最も利用されないブロックであるという仮定に基いている。

# コード例: バッファキャッシュ

バッファキャッシュは双方向のリンクリストのバッファである。
mainから呼ばれる関数binit(1231行目)によってリストがNBUF個のバッファによって静的なアレイbuf内で初期化される(4350-4359行目)。
全てのリンクリストを参照するバッファキャッシュへのアクセスはbcache.headを利用してアクセスされ、buf配列は利用されない。

バッファは3つの状態ビットを持っている。
B_VALIDはバッファ内にブロックのコピーが存在していることを示している。
B_DIRTYはバッファの内容が変更されており、ディスクに書き戻す必要があることを示している。
B_BUSYはいくつかのーアネルスレッドがそのバッファを参照しており、まだ解放されていないことを示す。

bread(4402行目)がbget関数を呼び、与えられたセクタのバッファを返す(4406行目)。
もしバッファをディスクから読む必要があれば、breadはiderwを呼び出して、バッファを返すようにする。
bget(4366行目)は与えられたデバイスとセクタ番号からバッファリストをスキャンする(4737-4384行目)。
もしそのようなバッファが存在し、バッファがビシーでなければ、bgetはB_BUSYフラグを立てて関数から戻る(4376ー4383行目)。
もしバッファが既に使用されていれば、bgetはバッファ上でスリープ状態に入り、解放されるのを待つ。
sleepから戻ると、bgetはバッファがまだ解放されていないとは仮定しない。
実際、sleepはbuf_table_lockを解放して、再度取得するが、bが正しいバッファである保証はない:
おそらく、異なるディスクセクタによって再利用されているであろう。
bgetは最初からやり直す(4383行目)必要があり、今度はまた別の時間に解決されることを期待している。

与えられたセクタがバッファキャッシュに存在しない場合、まず、bgetはおそらく別のセクタとして利用されている一つのバッファを再利用する必要がある。
次に、バッファリストをスキャンして、ビジーではないバッファを探索する: そのようなバッファは、どれでも使用可能である。
bgetはバッファのメタデータを編集し、新しいデバイスとセクタ番号を記録し、バッファから戻る前にバッファがビジーであることをマークする(4393行目)。
フラグの設定は,B_BUSYビットだけでなく、B_VALIDとB_DIRTYをクリアすることも忘れないようにする。
これにより、breadはバッファの過去の古い内容を読まずに、ブロクのデータをディスクから読むように設定される。

バファキャッシュは同期のためにも利用されるので、特定のディスクセクタに対してたった一つのバッファが利用されることは重要である。
割り当ての方法(4391-4393行目)は、bgetの最初のループによって、どのセクタにもバッファが存在しない状態のときのみ安全であるが、
but_table_lockが解放されてから、bgetは諦めないxxx

もし全てのバッファがビジーであるならば、何かが間違っているため、bgetはパニックで終了する。
より上品な対応としては、バッファがフリーになるまでスレープすることであるが、しかしそれでもデッドロックする可能性がある。

breadがバッファから呼び出し元に帰ると、呼び出し元はバッファを排他的に利用しており、データバイトの読み込みまたは書き込みができる。
もし読み出し元がデータの書き込みを行ったならば、bwriteを呼び出して、バッファを解放する前にディスクの書き込み処理を行う必要がある。
bwrite(4414行目)はB_DIRTYフラグを設定し、iderwを呼び出してバッファをディスクに書き込む。

読み出し元がバッファの処理を完了すると、brelseを呼び出して解放しなければならない(brelseはb-releaseがの略語であり、暗号めいてはいるが、学んでおく価値がある: Unixから利用されている言葉であり、BSD、Linux, Solarisでも利用されている)。
brelse(4425行目)はバッファをリンクリストの先頭に移動し(4432-4437行目)、B_BUSYビットをクリアし、バッファ上でスリープ状態になっているプロセスを起こす。
バッファを移動することによって、どのバッファが最近利用されたかが分かるようになっている(つまり、いつ解放されたかが分かるようになっている)。
最初のバッファは最も最近利用されたものであり、存在しているバッファのスキャンではワーストケースで処理する必要がある。し
しかし、最近利用されたバッファを最も最初にチェックすることによって(bcache.headから始まり、nextポインタを辿っていく)、参照局所性を活用してスキャンの時間を削減することができる。
最も最近利用されていないバッファを選択し再利用するためのスキャンでは、バッファを逆方向にスキャンすることで実現できる (prevポインタを辿っていく)。
