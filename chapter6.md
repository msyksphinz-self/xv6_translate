第6章 ファイルシステム
=====================

ファイルシステムの目的は、データを構成し保存することである。
ファイルシステムは典型的に、ユーザおよびアプリケーション間でデータを共有し、「維持する」ということである。
従って、ファイルはコンピュータを再起動しても存在し続ける。

xv6のファイルシステムはUNIXライクなものを提供しており、ファイル、ディレクトリ、パス名(第0章を参照のこと)をサポートし、IDEディスクに保存することいによって永続性を確保することができる(第3章を参照)。
ファイルシステムはいくつかの困難を解決する必要がある。

* ファイルシステムはツリー構成のディレクトリおよびファイルを表現するためのデータ構造をディスク上に構築する必要がある。また各ファイルの内容を保持するための識別子と、どのディスクエリアがフリーであるかの情報を保持しておく必要がある。
* ファイルシステムは「クラッシュからのリカバリ」をサポートする必要がある。つまり、もしクラッシュが発生しても(例えば、電源遮断など)、再起動後にファイルシステムは正しく動作する必要がある。
クラッシュのリスクは、データの更新の歳に割り込みが発生し、ディスク上のデータの一貫性に影響が出ことである(例えば、ファイルが存在することと、フリー状態であることを示すブロックのマークなど)。
* 異なるプロセがファイルシステムを同時に扱うため、不変性を維持するためにこれらの操作の更新をする必要がある。
* ディスクへのアクセスはメモリへのアクセスに比べて格段に遅く、従ってファイルシステムは頻繁に利用されるブロックについてメモリ上にキャッシュする仕組みを提供する必要がある。

本章では、上記の困難をxv6ではどのように解決しているかについて説明する。

# 概要

xv6のファイルシステムは図6-1に示すように7つのレイヤで構成されている。
ディスクレイヤは、IDEハードドライブのブロックを読み書きする。
バッファキャッシュレイヤはディスクブロックをキャッシュし、ブロックのアクセスの同期を取り、データが格納されている特定のブロックについて、たった一つのブロックのみが変更を行っていることを保証する。
ロギングレイヤは高位のレイヤのいくつかのブロックの更新操作を「トランザクション」としてラップし、またクラッシュが発生した場合でも、ブロックがアトミックに更新されたことを保証する(例えば、全てのブロックがアップデートされたか、または一つもアップデートされていないか)。
inodeレイヤは個々のファイルを提供し、それぞれのノードはinodeというユニークなi-numberと、ファイルを保持しているいくつかのブロックで構成される。
ディレクトリレイヤはいくつかのディレクトリを構成し、特別な種類のi-nodeとして構成さえる。
ディレクトリのinodeはディレクトリのエントリ列が含まれており、各エントリにはファイル名とi-numberが入っている。
パス名レイヤは、/usr/rtm/xv6/fs.cのような階層的なパス構成を提供し、階層的な探索によりそれを解決する。
ファイルディスクリプタレイヤは多くのUNIXの資源を抽象化する(例えば、パイプやデバイス、ファイルなど)。
これにはファイルシステムインタフェースを用い、これによりアプリケーションプログラマのプログラミングを簡単化する。

ファイルシステムはinodeをどこに格納して、デキスクのどこのブロックに内容を格納するかについての方針を決める必要がある。
これを行うためには、xv6は、図6-2に示すようにディスクをいくつかのセクションに分割する。
ファイルシステムはブロック0は使用しない(これはブートセクタを保持している)。
ブロック1は「スーパブロック」と呼ばれ、ファイルシステムのメタデータを格納している(ブロックのファイルサイズ、データブロックの数、inodeの数、ログ中のブロックの数).
ブロック2以降はinodeを保持しており、ブロックあたりに複数のinodeを保持している。
データブロックを辿っていたビットマップのブロックは、使用中である。
殆どの残りのブロックは、データブロックである; それぞれのブロックはビットマップブロック上でフリーであることをマークされており、ファイルもしくはディレクトリが保持されている。
ディスクの最後のブロックはロギングレイヤのログが格納されている。

本章の以降では、各レイヤについて議論する。まずはバッファキャッシュのレイヤから始まり、うまく選択された下位レイヤの抽象化により、上位のレイヤがより易しくなっていることを見ていこう。
