オペレーティングシステムの構成
=====================

オペレーティングシステムの鍵は、様々な活動をサポートすることである。例えば、第0章で述べたシステムコールを用いて、プロセスはforkを呼び出すことにより新しいプロセスを開始することができる。オペレーティングシステムはこれらのプロセスがコンピュータ上の資源を「時分割共有」できるように管理する必要がある。例えば、プロセスがコンピュータ上に存在するプロセッサ数よりも多くのプロセスを生成したとしたら、全てのプロセスは正しく動作しなければならない。加えて、オペレーティングシステムは各プロセスが「独立して」動作するための管理を行わなければならない。つまり、あるプロセスにバグがあり異常終了したとしても、そのプロセスと依存関係の無いプロセスに影響を与えてはならないということである。プロセス間で相互作用することを可能にするため、完全な独立性は非常に強力なものとなる(xxx); 例えば、ユーザにとって複雑なタスクを実行するために複数のプロセスを組み合せることは、便利なことである(例えば、パイプなど)。従って、オペレーティングシステムの実装は、「多重化、独立、相互作用」の3つの要件を達成する必要がある。
本章では、オペレーティングシステムが上記の3つの要件を満たすために、どのように構成されているかについて概要を説明する。これを実現するためには様々な手段が存在するが、本書では多くのUnixオペレーティングシステムでも採用されている「モノリシックカーネル」という方式を中心に、焦点を当てて説明を行う。本章では、この構成を、まずxv6が動作を開始し、最初のプロセスが開始したところからトレースすることにより説明する。この中で、本書ではxv6が提供する主たる抽象化について簡単に説明する。つまり、どのようにプロセスが相互作用を行い、どのようにして多重化、独立、相互作用の要求を満たすような構成を取っているのかについて説明する。xv6の殆どの部分は、最初のプロセスについての特別な場合分けについては避けており、xv6が提供する標準的な操作を再利用することで実現している。以降の章では、それぞれの抽象化についてより詳細に説明する。
xv6はPCプラットフォーム上で、Intelの30386よりも後続の("x86")のプロセッサで動作し、多くの低レイヤの機能(例えば、プロセスの実装など)はx86の仕様に則して作られている。本書の読者はいくつかのアーキテクチャについて少しのアセンブリレベルでのプログラミングの経験があり、x86の仕様については、必要なときに随時説明する。付録Aで、PCプラットフォームについて概要を説明している。

# 物理資源の抽象化

オペレーティングシステムについて考えるとき、最初に思い浮かぶ質問は、何故それが必要なのか？ということである。つまり、誰かが図0-2のシステムコールをライブラリとして実装しておき、アプリケーションとリンクさせておけば良いのではないか、と考える。この方法では、各アプリケーションは各々のライブラリを持っており、それぞれのアプリケーションで適切なライブラリを持っている。この方法では、アプリケーションはハードウェアと直接通信を行い、ハードウェア資源を、各々のアプリケーションが最適な方法で使用する(例えば、最高の性能を得るための構成や所望の性能を得るための構成でアクセスを行う)。組み込みデバイス向けのいくつかの小さなオペレーティングシステムや、リアルタイムシステム向けのオペレーティングシステムではこのような方法を取っている。
この方式の問題は、アプリケーションが自由にライブラリを使えることであり、つまりは各アプリケーションが「ライブラリを適切に使わない」ということである。もしアプリケーションがオペレーティングシステムのライブラリを利用しなければ、オペレーティングシステムは時分割共有を強制させることができない。各アプリケーションが正しく動作している、ということに依存するしかなくなり、例えば、定期的にプロセッサの取得を諦め、他のアプリケーションがプロセッッサを獲得するようにしなければならない。このような「協力作業が必要な」時分割共有の構成は、全てのアプリケーションが正しく動作していることを信用しても大丈夫かもしれないが、各アプリケーションが相互に信用ならないものであると、強力な独立性を提供することができなくなる。
強力な独立性を実現するためには、各アプリケーションが直接ハードウェア資源にアクセスすることを禁止し、その代わりに各資源をサービスとして抽象化することが有効だと思われる。例えば、各アプリケーションはファイルシステムに対してopen, read, write, closeなどのシステムコールでのみアクセスし、直接ディスクセクタは読まないようにする。これにより、アプリケーションがパス名を利用することによって、オペレーティングシステムが(インタフェースの実装者として)ディスクを管理することができるようになる。
同様に、Unixのアプリケーションがforkを用いてプロセスとして動作することにより、アプリケーションが異なるプロセス間でスイッチする際の、レジスタのセーブとリストアをオペレーティングシステムが実現することができるようになる。これにより、アプリケーションはプロセスのスイッチングについて気に掛ける必要が無くなる。さらに、例えば、アプリケーションが無限ループに陥ったとしても、オペレーティングシステムが強制的にアプリケーションをプロセッサの外にスイッチすることができるようになる。
別の例として、Unixのプロセスはexecを用いることにより、直接物理的なメモリを操作する代わりに、メモリイメージを構築できるようになる。これにより、オペレーティングシステムはどの領域をどのプロセスが使うかを決定し、メモリ領域が足りなければ領域の移動を行い、これらのイメージを格納しておくたえのファイルシステムの利便性をアプリケーションに提供できるようになる。
アプリケーション間で、制御された相互作用をサポートするために、Unixのアプリケーションはファイルディスクリプタのみを使うことができる。(例えば、物理的なメモリの一部を予約するといったような)他の共有のための方法を取ることはない。Unixのファイルディスクリプタは共有のための詳細を抽象化し、ターミナル、ファイルシステム、パイプなどを使ってアプリケーションの相互作用が発生したとしても、詳細を隠すことができるようになる。
図0-2に示すようなシステムコールのインタフェースは、注意深く設計され、利便性のためにプログラマに提供されているが、これらのインタフェースを実装することにより、強力な独立性を実現できている。Unixインタフェースは資源を抽象化するだけでなく、それが非常に良いものであるということを証明している。

# カーネルの構成
オペレーティングシステムの鍵となる設計の疑問として、オペレーティングシステムのどの部分をカーネルモードで実行すれば良いかということがあげられる。シンプルな回答は、システムコールインタフェースがカーネルインタフェースである。つまり、fork, exec, open, close, read, write などは全てカーネルコールである。この選択は、オペレーティングシステムの実装は全てカーネルモードで実行されるということを示している。このカーネル構成を「モノリシックカーネル」と呼ばれる。
この構成では、オペレーティングシステムの全ての部分は、最高のハードウェアの権限を持って実行される。この構成は、OSの設計者がどのオペレーティングシステムの部分で最高のハードウェアの権限が不要であるか考慮する必要が無いため便利である。さらに、オペレーティングシステムの異なる部分が協調することも簡単である。例えば、オペレーティングシステムはファイルシステムと仮想メモリシステムを共有するためのバッファキャッシュを持っている(xxx)。
モノリシックな構成の弱点は、オペレーティングシステムの異なる部分のインタフェースが、しばしば複雑ということである(これについては、本書の後の方で見ていく)。そのことにより、オペレーティングシステムの開発者は間違いを犯しやすくなる。モノリシックカーネルでは、カーネルモードでの異常終了はカーネルが異常終了したことと同じ意味のため、間違いは致命傷となる。もしカーネルが異常終了すると、コンピュータは動作しなくなり、アプリケーションも動作しなくなる。コンピュータは再起動せざるを得なくなるのである。
カーネルの間違いによるリスクを削減するためには、OSの設計者はなるべくカーネルモードで動作する猟奇を減らすことを考える。殆どのオペレーティングシステムが権限の必要な命令を実行することがなく、従ってユーザレベルアプリケーションとして動作させることができる。これにより、メッセージによりアプリケーション間で通信ができるようになる。このカーネルの構成を「マイクロカーネル」と呼ぶ。
図1-1は、マイクロカーネルの構成を示している。この図では、ファイルシステムはユーザレベルアプリケーションとして動作している。オペレーティングシステムでオリジナルのユーザプログラムとして動作するサービスは、サーバと呼ばれる。アプリケーション同士がファイルサーバを通じて相互作用を行うために、マイクロカーネルは、あるユーザモードのアプリケーションから他方のアプリケーションに向けてメッセージを送信する最小のメカニズムを提供している。例えば、もしシェルのようなアプリケーションがファイルを読み書きしたければ、ファイルサーバにメッセージを送信してレスポンスを待てば良い。

マイクロカーネルでは、カーネルインタフェースはいくつかの低レイヤの関数で構成されており、これらはアプリケーションを開始したり、I/Oを操作したり、アプリケーションに向けてメッセージを送信したりする。この構成により、オペレーティングシステムの殆どの機能はユーザレベルのサーバとして実装することができるようになるため、カーネルはより少ないコード量により実装することができるようになる。
現実の世界では、モノリシックカーネルとマイクロカーネルのオペレーティングシステムの両方が存在する。例えば、Linuxは殆どがモノリシックカーネルとして実装されているが、いくつかのOSの機能はユーザレベルのサーバとして実装されている(例えば、ウィンドウシステムなど)。xv6は、Unixオペレーティングシステムにならい、モノリシックカーネルとして実装されている。従って、オペレーティングシステムインタフェースはカーネルインタフェースに相当する。xv6は多くの機能をサポートしないため、xv6のカーネルはマイクロカーネルよりも小さい。


# # プロセスの概要
(Unixオペレーティングシステムとしての)xv6の独立性の単位は「プロセス」である。プロセスの抽象化によって、あるプロセスは他のプロセスからメモリの内容、CPUファイルディスクリプタなどの情報を破壊されたり、盗み見られたりすることを防ぐ。また、独立性によりプロセスがカーネルそのものを破壊してしまうことも防ぐ(例えば、独立性を強制することにより、カーネルを保護している)。カーネルはプロセス抽象化を実装していなければならず、これにより、バグのあるプログラムや悪意のあるプログラムがカーネルもしくはハードウェアに対して攻撃を仕掛ける(例えば、独立性を回避するなど)ことを防いでいる。カーネルにより利用されているプロセスを生成するメカニズムには、ユーザ/カーネルモードフラグ、アドレス空間、スレッドのタイムスライスなどが含まれており、これらについては本節にて概要を示す。
独立性を提供するために、プロセスは固有の抽象化されたマシンを持っているかのような抽象化を与えられる。プロセスはプログラムとプライベートなメモリシステム、もしくは「アドレス空間」を提供し、他のプロセスがその領域を読み書きすることを防ぐ。プロセスは同様にプログラムが自分の命令を実行するための固有のCPUを持っているかのように動作するための抽象化を提供する。
xv6はハードウェアにより実装されているページテーブルを利用して、各プロセスが固有のアドレス空間を保有することを実現している。図1-2に示すように、アドレス空間には、仮想アドレスの0番から始まる「ユーザメモリ」の領域が含まれている。まず命令が登場し、次にグローバルな変数、スタック、そして最後にヒープ領域(malloc用)が存在している。heap領域はプロセスが必要に応じて拡張できるように配置されている。
各プロセスのアドレス空間は、カーネルの命令とデータがユーザのプログラムメモリ上に同様にマップされている。プロセスがシステムコールを呼び出すと、プロセスのアドレス空間上にマップされたシステムコールが呼び出される。この構成により、カーネルのシステムコールのコードはユーザメモリを参照するようになっている。ユーザメモリ領域が拡張されていくことを想定して、xv6のアドレス空間では、カーネルは0x80100000から始まる高い領域にマップされている。
xv6カーネルは各プロセスの多くの状態を管理しており、それらはstruct proc(2353行目)により集められている。プロセスが保持するカーネル状態の最も重要な情報はそのページテーブルと、カーネルスタック、実行状態である。私達はp->xxxという表記によって、proc構造体のメンバ変数を表現することにする。
各プロセスは実行のスレッド(もしくは単に「スレッド」)を保持しており、これはプロセスの命令を実行するものである。スレッドはサスペンドしたり、再開したりするものである。プロセスの間を透過的にスイッチするためには、カーネルは現在実行されているスレッドをサスペンドし、他のプロセスのスレッドを再開させる。スレッドの非常に多くの状態(ローカル変数、関数コールのリターンアドレスなど)は、スレッドのスタックに保持されている。各プロセスは2つのスタックを持っている: ユーザスタックとカーネルスタックである(p->kstack)。プロセスがユーザ命令を実行しているならば、ユーザスタックのみが利用されており、カーネルスタックは～である。もしプロセスが(システムコールや割り込みなどにより)カーネルモードに入った場合、カーネルコードが実行され、プロセスのカーネルスタックが利用される; プロセスがカーネルモード中は、ユーザスタックは現在のデータを保持しているが、実際には使用されていない。プロセスのスレッドがは、ユーザモードとカーネルモードを、ユーザスタックとカーネルスタックを利用してアクティブに行き来する。カーネルスタックは分離されており(そしてユーザコードからも保護されている)、カーネルはプロセスのユーザスタックが破壊されていたとしても、カーネルコードを実行ることができるようにあんる。
プロセスがシステムコールを生成すると、プロセッサはカーネルスタックに遷移し、ハードウェアの権限レベルを上昇させる。そしてカーネル命令を実行開始する。システムコールが完了すると、カーネルはユーザ空間に戻ってくる: そしてハードウェアの権限は再び下がり、ユーザスタックに再びスイッチされ、システムコール命令が実行された直後からユーザ命令が実行される。プロセスのスレッドはI/Oなどを待つために実行を「ブロック」することができ、I/Oが完了すると、再び実行を再開する。
p->stateはプロセスの現在の実行状態を示す。これは「run:実行状態」「running:実行可能状態？(xxx)」「wait:待ち状態(I/O用)」「exit:終了状態」である。
p->pgdirはプロセスのページテーブルを保持しており、これはx86のハードウェアが期待するフォーマットを持っている。xv6はページングのハードウェアを起こすことでプロセスのp->pgdirを活用する。プロセスのページテーブルはプロセスのメモリを割り当て、情報を格納するための物理ページのアドレス情報を保持する役割も担っている。
