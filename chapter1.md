オペレーティングシステムの構成
=====================

オペレーティングシステムの重要な要件は、様々な活動をサポートすることである。例えば、第0章で述べたシステムコールを用いて、プロセスはforkを呼び出すことにより新しいプロセスを開始することができる。オペレーティングシステムはこれらのプロセスがコンピュータ上の資源を「時分割共有」できるように管理する必要がある。例えば、プロセスがコンピュータ上に存在するプロセッサ数よりも多くのプロセスを生成したとしたら、全てのプロセスは正しく動作しなければならない。加えて、オペレーティングシステムは各プロセスが「独立して」動作するための管理を行わなければならない。つまり、あるプロセスにバグがあり異常終了したとしても、そのプロセスと依存関係の無いプロセスに影響を与えてはならないということである。しかし完全な独立性というのは、強力すぎる。プロセス間で相互作用できるようにしなければならない。 例えば、ユーザにとって複雑なタスクを実行するために複数のプロセスを組み合せることは、便利なことである(例えば、パイプなど)。従って、オペレーティングシステムの実装は、「多重化、独立、相互作用」の3つの要件を達成する必要がある。
本章では、オペレーティングシステムが上記の3つの要件を満たすために、どのように構成されているかについて概要を説明する。これを実現するためには様々な手段が存在するが、本書では多くのUnixオペレーティングシステムで採用されている「モノリシックカーネル」という方式を中心に焦点を当てて説明を行う。本章では、この構成を説明するために、まずxv6が動作を開始し、最初のプロセスが開始したところからトレースすることまでを説明する。この中で、本書ではxv6が提供するメインの抽象化の考え方について簡単に説明する。つまり、どのようにプロセスが相互作用を行い、どのようにして多重化、独立性、相互作用の要求を満たす構成を取るのかについて説明する。xv6の殆どの部分では、システムで最初に起動するプロセスで必要な特別な場合分けについては避けており、xv6が提供する標準的な操作を再利用することで実現している。以降の章では、それぞれの抽象化についてより詳細に説明する。
xv6はPCプラットフォーム上で、Intelの30386よりも後続の("x86")のプロセッサで動作し、多くの低レイヤの機能(例えば、プロセスの実装など)はx86の仕様に則して作られている。本書の読者はいくつかのアーキテクチャについて少しのアセンブリレベルでのプログラミングの経験があると仮定し、x86の仕様については、必要なときに随時説明する。付録Aで、PCプラットフォームについて概要を説明している。

# 物理資源の抽象化

オペレーティングシステムについて考えるとき、最初に思い浮かぶ質問は、何故それが必要なのか？ということである。つまり、誰かが図0-2のシステムコールをライブラリとして実装しておき、アプリケーションとリンクさせておけば良いのではないか、ということである。この方法では、各アプリケーションは各々で、要件に最適なライブラリを持っている。この方法だとアプリケーションはハードウェアと直接通信を行い、ハードウェア資源を各々のアプリケーションが最適な方法で使用する(例えば、最高の性能を得るための構成や所望の性能を得るための構成でアクセスを行う)。組み込みデバイス向けのいくつかの小さなオペレーティングシステムや、リアルタイムシステム向けのオペレーティングシステムではこのような方法を取っている。
この方式の問題は、アプリケーションが自由にライブラリを使えることであり、つまりは各アプリケーションが「ライブラリを適切に使わない」ということである。もしアプリケーションがオペレーティングシステムのライブラリを利用しなければ、オペレーティングシステムは時分割共有を強制させることができない。各アプリケーションが正しく動作していることを信じるしかなくなるため、各アプリケーションは例えば定期的にプロセッサの取得を諦め、他のアプリケーションがプロセッッサを獲得するようにしなければならない。このような「協力作業が必要な」時分割共有の実現は、全てのアプリケーションが正しく動作していることを信用すれば正しく動作するかもしれないが、各アプリケーションが相互に信用ならない場合、強力な独立性を提供することができなくなる。
強力な独立性を実現するためには、各アプリケーションが直接ハードウェア資源にアクセスすることを禁止し、その代わりに各資源をサービスとして抽象化することが有効だと思われる。例えば、各アプリケーションはファイルシステムに対してopen, read, write, closeなどのシステムコールでのみアクセスし、直接ディスクセクタは読まないようにする。これにより、アプリケーションはパス名を利用することでオペレーティングシステムが(インタフェースの実装者として)ディスクを管理することができるようになる。
同様に、Unixのアプリケーションがforkを用いてプロセスとして動作することにより、アプリケーションが異なるプロセス間でスイッチする際のレジスタのセーブと回復をオペレーティングシステムが実現できるようになる。これにより、アプリケーションはプロセスのスイッチングについて気に掛ける必要が無くなる。さらに、例えば、アプリケーションが無限ループに陥ったとしても、オペレーティングシステムが強制的にそのアプリケーションのプロセッサ利用権限を取り上げることができるようになる。
別の例として、Unixのプロセスはexecを用いることにより、直接物理的なメモリを操作する代わりに、メモリイメージを構築できるようになる。これにより、オペレーティングシステムはどの領域をどのプロセスが使うかを決定し、メモリ領域が足りなければ領域の移動を行えるようになる。オペレーティングシステムはオプリーケションにファイルシステムを提供し、イメージを格納する利便性を提供できるようになる。
アプリケーション間でコントロールされた相互作用をサポートするために、Unixのアプリケーションはファイルディスクリプタのみを使うことができる。(例えば、物理的なメモリの一部を予約するといったような)他の共有方法を取ることはない。Unixのファイルディスクリプタは共有のための詳細を抽象化し、ターミナル、ファイルシステム、パイプなどを使ってアプリケーションの相互作用が発生したとしても、詳細を隠すことができる。
図0-2に示すようなシステムコールのインタフェースは、注意深く設計され、利便性のためにプログラマに提供されているが、これらのインタフェースを実装することにより、強力な独立性を実現できている。Unixインタフェースは資源を抽象化するだけでなく、それが非常に良いものであるということを証明している。

# カーネルの構成
オペレーティングシステムの重要な設計の疑問点として、オペレーティングシステムのどの部分をカーネルモードで実行すれば良いかということがあげられる。シンプルな回答は、システムコールインタフェースがカーネルインタフェースである。つまり、fork, exec, open, close, read, write などは全てカーネルコールである。この選択は、オペレーティングシステムの実装は全てカーネルモードで実行されるということを示している。このカーネル構成を「モノリシックカーネル」と呼ばれる。
この構成では、オペレーティングシステムの全ての部分は、最高のハードウェアの権限を持って実行される。この構成はOSの設計者にとって、最高のハードウェアの権限が必要な領域と不要な領域について考慮する必要が無いため便利である。さらに、オペレーティングシステムの異なる部分が協調することも簡単である。例えば、オペレーティングシステムはファイルシステムと仮想メモリシステムを共有するためのバッファキャッシュを持っている(xxx)。
モノリシックな構成の弱点は、オペレーティングシステムの異なる部分のインタフェースが、しばしば複雑ということである(これについては、本書の後の方で見ていく)。そのことにより、オペレーティングシステムの開発者は間違いを犯しやすくなる。モノリシックカーネルでは、カーネルモードでの異常終了はカーネルが異常終了したことと同じ意味のため、間違いは致命傷となる。もしカーネルが異常終了すると、コンピュータは動作しなくなり、アプリケーションも動作しなくなる。コンピュータは再起動せざるを得なくなるのである。
カーネルの間違いによるリスクを削減するためには、OSの設計者はなるべくカーネルモードで動作する猟奇を減らすことを考える。殆どのオペレーティングシステムが権限の必要な命令を実行することがなく、従ってユーザレベルアプリケーションとして動作させることができる。これにより、メッセージによりアプリケーション間で通信ができるようになる。このカーネルの構成を「マイクロカーネル」と呼ぶ。
図1-1は、マイクロカーネルの構成を示している。この図では、ファイルシステムはユーザレベルアプリケーションとして動作している。オペレーティングシステムでオリジナルのユーザプログラムとして動作するサービスは、サーバと呼ばれる。アプリケーション同士がファイルサーバを通じて相互作用を行うために、マイクロカーネルは、あるユーザモードのアプリケーションから他方のアプリケーションに向けてメッセージを送信する最小のメカニズムを提供している。例えば、もしシェルのようなアプリケーションがファイルを読み書きしたければ、ファイルサーバにメッセージを送信してレスポンスを待てば良い。

マイクロカーネルでは、カーネルインタフェースはいくつかの低レイヤの関数で構成されており、これらはアプリケーションを開始したり、I/Oを操作したり、アプリケーションに向けてメッセージを送信したりする。この構成により、オペレーティングシステムの殆どの機能はユーザレベルのサーバとして実装することができるようになるため、カーネルはより少ないコード量により実装することができるようになる。
現実の世界では、モノリシックカーネルとマイクロカーネルのオペレーティングシステムの両方が存在する。例えば、Linuxは殆どがモノリシックカーネルとして実装されているが、いくつかのOSの機能はユーザレベルのサーバとして実装されている(例えば、ウィンドウシステムなど)。xv6は、Unixオペレーティングシステムにならい、モノリシックカーネルとして実装されている。従って、オペレーティングシステムインタフェースはカーネルインタフェースに相当する。xv6は多くの機能をサポートしないため、xv6のカーネルはマイクロカーネルよりも小さい。


# # プロセスの概要
(Unixオペレーティングシステムとしての)xv6の独立性の単位は「プロセス」である。プロセスの抽象化によって、あるプロセスは他のプロセスからメモリの内容、CPUファイルディスクリプタなどの情報を破壊されたり、盗み見られたりすることを防ぐ。また、独立性によりプロセスがカーネルそのものを破壊してしまうことも防ぐ(例えば、独立性を強制することにより、カーネルを保護している)。カーネルはプロセス抽象化を実装していなければならず、これにより、バグのあるプログラムや悪意のあるプログラムがカーネルもしくはハードウェアに対して攻撃を仕掛ける(例えば、独立性を回避するなど)ことを防いでいる。カーネルにより利用されているプロセスを生成するメカニズムには、ユーザ/カーネルモードフラグ、アドレス空間、スレッドのタイムスライスなどが含まれており、これらについては本節にて概要を示す。
独立性を提供するために、プロセスは固有の抽象化されたマシンを持っているかのような抽象化を与えられる。プロセスはプログラムとプライベートなメモリシステム、もしくは「アドレス空間」を提供し、他のプロセスがその領域を読み書きすることを防ぐ。プロセスは同様にプログラムが自分の命令を実行するための固有のCPUを持っているかのように動作するための抽象化を提供する。
xv6はハードウェアにより実装されているページテーブルを利用して、各プロセスが固有のアドレス空間を保有することを実現している。図1-2に示すように、アドレス空間には、仮想アドレスの0番から始まる「ユーザメモリ」の領域が含まれている。まず命令が登場し、次にグローバルな変数、スタック、そして最後にヒープ領域(malloc用)が存在している。heap領域はプロセスが必要に応じて拡張できるように配置されている。
各プロセスのアドレス空間は、カーネルの命令とデータがユーザのプログラムメモリ上に同様にマップされている。プロセスがシステムコールを呼び出すと、プロセスのアドレス空間上にマップされたシステムコールが呼び出される。この構成により、カーネルのシステムコールのコードはユーザメモリを参照するようになっている。ユーザメモリ領域が拡張されていくことを想定して、xv6のアドレス空間では、カーネルは0x80100000から始まる高い領域にマップされている。
xv6カーネルは各プロセスの多くの状態を管理しており、それらはstruct proc(2353行目)により集められている。プロセスが保持するカーネル状態の最も重要な情報はそのページテーブルと、カーネルスタック、実行状態である。私達はp->xxxという表記によって、proc構造体のメンバ変数を表現することにする。
各プロセスは実行のスレッド(もしくは単に「スレッド」)を保持しており、これはプロセスの命令を実行するものである。スレッドはサスペンドしたり、再開したりするものである。プロセスの間を透過的にスイッチするためには、カーネルは現在実行されているスレッドをサスペンドし、他のプロセスのスレッドを再開させる。スレッドの非常に多くの状態(ローカル変数、関数コールのリターンアドレスなど)は、スレッドのスタックに保持されている。各プロセスは2つのスタックを持っている: ユーザスタックとカーネルスタックである(p->kstack)。プロセスがユーザ命令を実行しているならば、ユーザスタックのみが利用されており、カーネルスタックは～である。もしプロセスが(システムコールや割り込みなどにより)カーネルモードに入った場合、カーネルコードが実行され、プロセスのカーネルスタックが利用される; プロセスがカーネルモード中は、ユーザスタックは現在のデータを保持しているが、実際には使用されていない。プロセスのスレッドがは、ユーザモードとカーネルモードを、ユーザスタックとカーネルスタックを利用してアクティブに行き来する。カーネルスタックは分離されており(そしてユーザコードからも保護されている)、カーネルはプロセスのユーザスタックが破壊されていたとしても、カーネルコードを実行ることができるようにあんる。
プロセスがシステムコールを生成すると、プロセッサはカーネルスタックに遷移し、ハードウェアの権限レベルを上昇させる。そしてカーネル命令を実行開始する。システムコールが完了すると、カーネルはユーザ空間に戻ってくる: そしてハードウェアの権限は再び下がり、ユーザスタックに再びスイッチされ、システムコール命令が実行された直後からユーザ命令が実行される。プロセスのスレッドはI/Oなどを待つために実行を「ブロック」することができ、I/Oが完了すると、再び実行を再開する。
p->stateはプロセスの現在の実行状態を示す。これは「run:実行状態」「running:実行可能状態？(xxx)」「wait:待ち状態(I/O用)」「exit:終了状態」である。
p->pgdirはプロセスのページテーブルを保持しており、これはx86のハードウェアが期待するフォーマットを持っている。xv6はページングのハードウェアを起こすことでプロセスのp->pgdirを活用する。プロセスのページテーブルはプロセスのメモリを割り当て、情報を格納するための物理ページのアドレス情報を保持する役割も担っている。

# コード例: 最初のアドレス空間
xv6の構造をより具体的に紹介するために、私達は、カーネルが、カーネル自身のために、最初のアドレス空間をどのようにして作成するのかについて見ていく。カーネルがどのようにしてアドレス空間を作成し、どのようにして最初のプロセスを開始っし、最初のプロセスを作るためのシステムコールをどのようにして呼び出すのかについて見ていく。これらの操作をトレースすることにより、私達はxv6がどのようにプロセスの協力な独立性を提供しているのかを見ることができる。最初のステップとして協力の独立性はカーネルが自分自身のアドレス空間上で実行する状態を構築するところからである。
PCの電源を入れると、PCは自分自身を初期化して「ブートローダ(boot loader)」をディスクからメモリに展開し、実行する。付録Bにその詳細を説明している。xv6のブートローダはxv6のカーネルをディスクから読み出して、entryから実行を開始する(1040行目)。x86のページングのハードウェアはカーネルが実行された時点では有効になっていない; 仮想アドレスは物理アドレスを直接マッピングした状態になっている。
ブートローダがxv6のカーネルを物理アドレスの0x100000へロードする。カーネルを0x80100000へロードしない理由は、カーネルは自分自身の命令とデータが、小さなマシンだと大きな物理メモリなアドレス空間に配置できない状況を想定して、このような配置になっている。カーネルを0x0に配置するのではなく、0x100000に配置する理由は、0xa0000から0x100000にはI/Oデバイスが含まれているからである。
このentryのページテーブルはmain.cに定義されている(1311行目)。ページテーブルの詳細は第2章で見ていくが、簡単に説明するとエントリ0は仮想アドレス0:0x400000を物理アドレス0:00x400000にマッピングしている。このマッピングは、entryが低いアドレスで実行れている期間は必要な設定であり、しかし最終的には削除される。
Entryの512番目は仮想アドレスKERNBASE:KERNBASE+0x400000を物理アドレス0:0x400000にマッピングしている。このエントリはカーネルがentryを実行し終えたときに利用される; カーネルはより高い仮想アドレスにマッピングされるが、カーネルは命令やデータがブートローダのロードしたより低いアドレスで実行されることを想定している。このマッピングにより、カーネルの命令とデータは4Mバイト以内である制限が生じる。
entryに戻ると、entryはentrypgdirの物理アドレスを制御レジスタ%cr3にロードする。ページングハードウェアはentrypgdirの物理アドレスを知っていなければならない。これは、ページングハードウェア仮想アドレスの変換方法をまだ知らないからである; まだページテーブルは存在していないのである。シンボルentrypgdirは高いメモリ空間のアドレスを指し、マクロV2P_W0(0220行目)は物理アドレスを算出するためにKERNBASEを減算するためのマクロである。ページングハードウェアを有効にするためには、xv6は%cr0レジスタに対してCR0_PGをフラグを設定する。
ページングが有効になったとしても、プロセッサは相変わらず低いアドレス上で実行されており、これはentrypgdirが低いアドレスにマッピングされているからである。もしxv6がentrypgdirからエントリ0を取り除くと、コンピュータは有効化されたページ(xxx)を実行しようとしてクラッシュすることである。
今現在、entryはカーネルのCコードに遷移する必要があり、高いメモリアドレスに遷移して実行する必要がある。まずスタックポインタ%espを作成し、メモリのスタック領域に設定する(1054)。stackを含む全てのシンボルは高いアドレス空間上に配置されているため、低いマッピンが除去されたとしてもスタックは有効である。最後にentryはmainにジャンプして、高いアドレスに遷移する。この間接的なジャンプを実現するためにはアセンブラが必要であり、そうでなければ、コンパイラはPC相対の直接ジャンプを生成し、低いメモリ領域のmainを実行してしまう。PCはスタック上に格納されていないため、mainはリターンすることはできない。ここからは、カーネルは高いアドレスのmainに遷移して実行を開始するのである。
# コード例: 最初のプロセスを生成する
これまでで、カーネルは自分のアドレス空間で実行することができるようになった。次に、カーネルはどのようにしてユーザレベルプロセスを生成し、どのようにしてカーネルプロセスとユーザレベルプロセス、そしてプロセスそのもの同士の独立性を保つのかを見ていく。
main関数がいくつかのデバイスとサブシステムを初期化すると、main関数はuserinit(1239行目)を呼び出して最初のプロセスを作成する。userinit関数の最初の仕事は、allocprocを呼び出すことである。allocproc(2455行目)の仕事はプロセステーブルのスロット(struct proc構造体)とカーネルスレッドが実行可能になるために、プロセスの状態を初期化することである。allocprocは新しいプロセスが生成されると呼び出されるが、一方でuserinitは最初のプロセスでしか呼ばれない。allocprocはprocテーブルをスキャンして、UNUSEDな状態のスロットを探索する(2461-2463行目)。利用していないスロットを探索すると、allocprocはそのスロットの状態をEMBRYOとして利用できるようにマークし、プロセスのユニークなpidを割り当てる(2451-2469行目)。次に、allocprocはプロセスのカーネルスレッドのためにカーネルスタックを割り当てる。もしメモリ割り当てに失敗すると、allocprocはその状態をUNUSEDとし、ゼロを返し失敗であることを通知する。

今現在、allocprocは新しいプロセスのためのカーネルスタックを構築しなければならない。allocprocは最初のプロセスを生成するのと同様に、forkを使って記述することができる。allocprocは特別に容易されたカーネルスタックと、最初に実行が開始されたときにユーザ空間に「戻る」ためにいくつかのカーネルレジスタの設定する。図1-4に、準備の完了したカーネルスタックのレイアウトを示す。allocprocはこの一連の動作の中の一部分を担い、新しいプロセスのカーネルスレットが、forkretされ、さらにtrapretにより最初に実行されるときのための戻り値となるプログラムカウンタを設定する役割を担っている(2486-2491)。カーネルスレッドは、p->contextからコピーされた命令と、レジスタ内容を用いて実行を開始する。よって、p->context->eipをforkretに設定することによって、forkretの戦闘からカーネルスレッドが動作するようになる(2783)。この関数はスタックの底辺に格納されているアドレスに戻ってくる。コンテキストスイッチを実現するためのコード(2958行目)は、スタックポインタをp->contextの一つ上を指すように設定する。allocprocはp->contextをスタックの上に載せ、その上にtrapretを載せる；これにより、forkretに戻されることになる。trapretはカーネルスタックのトップに格納されているユーザレジスタを書き戻し、プロセスにジャンプする(3277行目)。このセットアップは、オリジナルのforkの動作と最初のプロセスを生成する手順と同一であるが、最初のプロセスを生成する手順では、forkから帰ってから実行するのではなく、ユーザ空間のアドレス0から実行を開始する。

第3章でも見るが、ユーザソフトウェアからカーネルへ制御を転送する方法は、システムコール、割り込み、例外などの割り込み機構を用いて実現される。プロセスが実行中に制御がカーネルに遷移しても、ハードウェアとxv6のtrapエントリコードがユーザレジスタをプロセスのカーネルスタック上に保存する。userinitは新しいスタックの上に値を書き込み、プロセスが割り込みによりカーネルに入ったときに、あたかもそこに存在していたかのような状況を実現する。これにより、カーネルスタックから戻ってきて、プロセスのユーザコードに遷移するコードは、正しく動作するのである。これらの値は、ユーザレジスタに格納されているstruct trapframeである。ここで、新しいプロセスのカーネルスタックは図1-4に示すように、完全に準備されたものになっている。
最初のプロセスは、小さなプログラム(initcode.S(8200行目))を実行する。プロセスにはプログラムを格納するための物理的なメモリが必要であり、プログラムはそのメモリにコピーされなければならない。またプロセスはメモリを参照するためにページテーブルを設定しなければならない。
userinitはsetupkvm(1837行目)を呼び出して、(最初に)プロセスのページテーブルを、カーネルが使うようにメモリのみをマッピングする。第2章でこの関数については詳細に学ぶが、大まかに見れば、setupkvmとuserinitは図1-2に示すようなアドレス空間を生成する。
最初のプロセスのメモリの初期内容は、initcode.Sからコピーされる。これはカーネルのビルドプロセスの一部であり、リンカがこのバイナリをカーネルに埋め込み、2つの特別なシンボルを定義する。これが_binary_initcode_startと_binary_initcode_sizeである。これらはバイナリの場所とサイズを示している。userinitはinituvmを呼び出すことによりこのバイナリを新しいプロセスのメモリ空間にコピーする。inituvmは物理メモリのページを割り当て、そのメモリ空間を仮想アドレスの0番にマッピングする。そしてバイナリをページの領域にコピーするのである(1903行目)。
userinitは初期のユーザモードの状態とともに、トラップフレームを設定する:%csレジスタにはDPL_USERの権限で動作しているSEG_UCODEセグメントのためのセグメントセレクタが入っており、同様に%ds,%es,%ssも権限DPL_USERとしてSEG_UDATAを利用する。%eflagsのFL_IFビットは、ハードウェアの割り込みを許可するために設定され、これらは第3章で再び調査する。
スタックポインタ%espはプロセスの最も大きな、有効仮想アドレスであるp->szに設定される。この命令ポインタは初期化コードのエントリポイントである、アドレス0に設定される。
関数userinitはp->nameをinicodeに設定する。これはデバッグ用である。p->cwdを設定することにより、プロセスの現在のワーキングディレクトリを設定する;第6章では、nameiについて詳細を調査していく。
一度プロセスが初期化されると、userinitはp->stateをRUNNABLEに設定し、スケジュール可能な状態であることをマークする。

# コード例: 最初のプロセスを実行する
ここまでで、最初のプロセスの実行準備が整った。いよいよ実行する時だ。mainがuserinitを呼び出と、mpmainがschedulerを呼び、プロセスの実行を開始する(1267行目)。scheduler(2708)はp->stateがRUNNNABLEとなっているプロセスを探すが、それは1つしか存在しない： initprocである。schedulerはCPU毎の変数であるprocをその見つかったプロセスのものに設定し、swithuvmを呼び、そのプロセスのページテーブルを利用して実行を開始するためにハードウェアに通知する(1868)。カーネルの実行中にページテーブルが変更されることがあるが、それはsetupkvmが、カーネルのコードとデータのマッピングが全て一位になるように設定するからである。switchuvmはタスクの状態セグメントSEG_TSSを設定し、これはハードウェアにプロセスのカーネルスタックがハードウェアに対して、プロセスのカーネルスタック上でシステムコールもしくは割り込みを実行中するように通知する。第3章で、タスクの状態セグメントについて再度詳細を見ていく。
schedulerはp->stateをRUNNNIGに設定し、swtch(2958行目)を呼び出すことで、ターゲットのプロセスのカーネルスレッドにコンテキストがスイッチされるようにする。swtchは現在のレジスタを保存し、ターゲットのカーネルスレッドの保存されたレジスタを、x86のハードウェアのレジスタに対してロードする(これはproc->contextに格納されている)。このロードされるレジスタには、命令ポインタやスタックポインタも含まれている。現在のコンテキストはプロセスに割り当てられているというよりも、CPU毎の特殊なスケジューラコンテキストに割り当てられているというほうが正しい。従って、schedulerはswtchを呼び出し、CPU毎の記憶領域に、現在のハードウェアレジスタを保存する(cpu->scheduler)。ここで、任意のプロセスのカーネルスレッドを保存する訳ではない。swtchについては、第5章でより詳細を見ていく。最後のret命令(2977行目)によって、スックからターゲットとなるプロセスの%eipをポップし、コンテキストスイッチが完了する。こうして、プロセッサは、プロセスpのカーネルスタック上で実行が開始されるのである。
allocprocはinitprocのp->context->eipをforkretに設定し、retはforkretを実行する。最初の起動によって(これがこの場合xxxにあたる)、forkret(2783行目)は初期化関数を実行する。この初期化関数は、自分のカーネルスタック上で通常のプロセスのコンテキストで実行しなければならないため、mainでは実行することができない。次に、forkretの実行が終了する。allocprocはスタックから上位のデータを取り出し、p->contextかポップされる。これにはtrapretが格納されている。従って、次に%espにp->tfが設定され、trapretが実行を開始される。trapret(3277行目)はカーネルコンテキストにてswtchがやったように、pop命令を利用してトラップフレームからレジスタを回復する(602行目)。popalは汎用レジスタを回復し、popl命令が%gs,%fs,%es,%dsを回復する。addlはtrapnoとerrcodeの2つのフィールドをスキッする。トラップフレームのコンテキストはCPUの状態に遷移し、プロセッサは指定されたトラップフレーム上で%eipを設定して実行を続ける。inttprocのため、これは仮想アドレスが0、つまりinitcode.Sの先頭であることを示す。
ここでは,%eipは0を保持しており、%espは4096を保持している。これらはプロセスのアドレス空間の仮想アドレスである。プロセッサのページングハードウェアはこれを物理アドレスに変換する。allocuvmはプロセスのページテーブルを設定し、仮想アドレス0はプロセスに割り当てられた物理メモリを参照することになり、そしてPTE_Uフラグが設定され、ページングのハードウェアがユーザコードにより有効になりメモリにアクセスできるようになる。userinit(2514行目(が%csの低ビットを設定することにより、CPL=3のプロセスのユーザコードが実行される。これは、ユーザコードはPTE_Uが設定された状態でのみページを利用することができ、%cr3のような設定の肝となるハードウェアレジスタを変更することはできないことを意味する。従って、プロセスは自分自身のメモリのみを参照するように制限される。

# 最初のシステムコール: exec
これまでで、カーネルがプロセスに対してどのように強力な独立性を与えるのかを見てきた。次に、どのようにしてユーザレベルプロセスは、自分自身では処理できないサービスをカーネルに入るのかについて見ていく。
initcode.Sの最初の動作は、execシステムコールを呼ぶことである。第0章で見たように、execは現在のプロセスのレジスタやメモリの情報を、新しいプログラムのものに入れ替える。しかしファイルディスクリプタ、プロセスID、親プロセスIDは保持する。
initcode.S(8208行目)は$argv,$init,$0をスタックにプッシュすることから始まる--そして%eaxにSYS_execを設定しint T_SYSCALLを実行する: これは、カーネルに、NULLで終了する文字列/initへのポインタである、$initと呼ばれるプログラムを実行するものである(8221-8223行目)。もしexecの実行に失敗し戻ってくると、初期化コードはexitシステムコールを呼び続け、決して呼び出し元には戻っていかない(8215-8219行目)。
execシステムコールの引数は$initと$argvである。最後の0が、この手書きのシステムコールが、第3章で見るオリジナルのシステムコールに似ているように見せている。その前に、この設定ルーチンは最初のプロセスのための特殊ケース(この場合は、最初のシステムコール)の実行を避けている。その代わりに、xv6が標準的な操作として提供しなければならないコードを再利用しているのである。
第2章では、execの実装の詳細について述べるが、上いのレベルではinitcodeを/initバイナリに置換し、ファイルシステムからロードする。ここで、initcode(8200行目)が完了すると、プロセスは/initを代わりに実行し始める。init(8310行目)は必要ならば新しいコンソールデバイスファイルを作成し、それをファイルディスクリプタ0,1,2として開く。次に、initがループし、コンソールシェルを実行し、シェルが終了するまで、親を失なったゾンビプロセスの処理などを繰替えす。これでシステムは立ち上がった。

# 現実の世界
殆どのオペレーティングシステムはプロセスの概念に適合しており、殆どのプロセスはxv6のものと似ている。実際のオペレーティングシステムは、空き状態のproc構造体を、allocprocのように線形時間で探索するのではなく、明示的なフリーリストを用いて固定時間で探索する; xv6は簡単化のために、線形探索(最初に到達した空の構造体)を行う。
xv6のアドレス空間のレイアウトは、2GB以上の物理的なRAMを利用することができない場合に欠陥が生じる。最良の解決法はマシンのアドレス空間を64ビットに変更することだが、そうでなくても修正することはできる。

# 演習問題
1. swtchにブレークポイントを設定せよ。gdbのstepiを用いてシングルステップ実行を行い、forkretに到達するまで続けよ。次に、gdbのfinishを用いて、trapretまで実行せよ。次にstepiを実行して、仮想アドレス0に存在するinitcodeまで実行せよ。
2. KERNBASEは、ひとつのプロセスが利用することのできる最大のメモリ量を制限しており、もしマシンが4GBのRAMを搭載した場合には邪魔な要素となる。KERNBASE値を増加させることにより、プロセスがより多くのメモリを利用することができるようになるか？
