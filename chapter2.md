ページテーブル
=========

ページテーブルは、オペレーティングシステムがメモリアドレスの意味を制御するために必要なメカニズムである。ページテーブルにより、xv6は複数のプロセスが複数のアドレス空間を持つことができるようになり、さらに他のプロセス間でメモリ領域を犯すことを防ぐことができるようになる。ページテーブルにり提供される間接的なレベル付けにより、多くの巧妙な手段を利用することができるようになる。xv6はページテーブルをアドレス空間の分割とメモリの保護に利用する。それ以外にも、いくつかの簡単なページテーブルのトリックが存在する:いくつかのアドレス空間を同一のメモリにマッピングする、同じメモリ領域を1つ以上のアドレス空間にマッピングする(各ユーザページはカーネルの物理的なメモリ領域にマップされる)、ユーザスタックをマッピングされていないページから守る、などのことが可能になる。本章では、x86ハードウェアが提供するページテーブルについて説明し、xv6がそれをどのように利用しているのかについて見る。

# ページングハードウェア
備忘録として、x86命令は(ユーザ命令もカーネル命令も)仮想アドレス空間を操作することを覚えておこう。マシンのRAM、物理メモリは物理アドレスによってインデックが付与されている。x86ページテーブルハードウェアは、仮想アドレスから物理アドレスに向けてマッピングをすることにより、これらの2つのアドレスを結び付けている。
x86ページテーブルは、論理的には2^20(1,048,576)個のページテーブルエントリ(PTE)の配列である。各PTEは20ビットの物理ページ番号(PPN)といくつかのフラグを保持している。ページングハードウェアはこの上位の20ビットを使いPTEを探すためにページテーブルのインデックスに変換する。ページングハードウェアは下位の12ビットについては、仮想アドレスから物理アドレスの変換では変更しない。これにより、ページテーブルはオペレーティングシステムに対して仮想アドレスから物理アドレスに変換する手段を提供する。このときに、4096(2^12)バイトのアラインされた塊が並ぶことになる。このような塊のことを **ページ** と呼ぶ。

図2-1に示すように、実際ん変換には2ステップがかかっている。ページテーブルは2レベル木として物理メモリに格納されている。木のルートは4096バイトの **ページディレクトリ** であり、1024個のPTEのような **ページテーブルページ** を提供している。各ページテーブルページは2014個の32ビットPTEである。ページングハードウェアは、仮想アドレスの上位の10ビットを使ってページディレクトリのエントリを選択する。もしページディレクトリのエントリが存在すれば、ページングハードウェアは次の10ビットを使ってページディレクトリページが参照しているページテーブルページからPTEを選択する。もしページディレクトリエントリかPTEが存在していなければ、ページングハードウェアは失敗を宣告する。この2レベルの構造により、ページテーブルはが非常に幅広いアドレス空間からマッピングの存在しない殆どのケースを除外することができるようになる。
各PTEにはフラグビットが格納されており、関連付けられたアドレスが利用できるかどうかを示している。PTE_PはPTEが存在しているかを示している:もしこれがセットされてなければ、ページの参照によりエラーが発生する(つまり、許可されていない)。PTE_Wはどの命令がページへ書き込みを発行して良いかを制御してチェックする。もしこのビットがセットされていないと、その領域からはページのデータ読み込みとフェッチのみがサポートされるようになる。図2-1はこれらがどのように動作しているかを示している。フラグと全ての他のページハードウェアはmmu.h(700行目)に記述されている。
ここで、いくつか用語について補足しておく。物理メモリはDRAM上の保存用セルを参照している。物理メモリの1バイトは、物理アドレスと呼ばれるアドレスを持っている。命令は常に仮想アドレスしか利用しない。ページングハードウェアはこれを物理アドレスに変換し、これをDRAMに転送しストレージの読み書きを行う。このディスカッションのレベルでは、仮想メモリアドレスだけで、仮想メモリがxxxのようなものは無い。

# プロセスのアドレス空間
**entry** によって作成されたページテーブルは、カーネルのCコードを実行させるにはまだ十分なマッピングを備えてはいない。しかし、mainはkvmalloc(1857行目)を即座に呼び出して、新しいページテーブルに変更する。何故ならば、カーネルはプロセスのアドレス空間を記述するためのより洗練された計画を持っているからである。
各プロセスは分離されたページテーブルを保持しており、xv6のプロセスが切り替わるとき、xv6はページテーブルのハードウェアに対してペジテーブルをスイッチするように指示する。
図2-2に示すように、プロセスのユーザメモリは仮想アドレス0番地から始まり、KERNBASEまで広がっている。プロセスは最大で2GBまでのメモリを確保している。memlayout.h(200行目)によってxv6のメモリレイアウトのための定数を宣言しており、仮想アドレスから物理アドレスへの変換マクロを定義している。
プロセスがより多くのメモリを必要とすると、xv6はより多くのストレージを確保するためにフリーな物理ページを探し、PTEをそのプロセスのページテーブルに追加し、新しい物理ページを指すようにする。xv6はPTEに対してPTE_U,PTE_W,PTE_Pフラグを設定する。殆どのプロセッサはプロセスのユーザのアドレス空間全体を利用することは無い; xv6は使用していないPTEに対しては、PTE_Pをクリアにしておく。異なるプロセスのページテーブルがユーザアドレスを異なる物理メモリのページに変換するため、各プロセスはプライベートなユーザメモリを確保することができる。
xv6はカーネルが全てのプロセスのページテーブルで実行するために必要なマッピングも持っている; これらののマッピングはKERNBASEの上位に登場する。このマッピングは、仮想アドレスのKERNBASE:KERNBASE+PHYSTOPから0:PHYSTOPまでをマッピングする。このマッピングの理由は、カーネルがカーネル自身の命令とデータを利用できるようにするためである。もう一つの理由はカーネルはしばしば与えられた物理メモリのページに書き込む必要がある。例えば、ページテーブルを作成したときは、予測可能な仮想アドレスで、全てのページテーブルが保持されていたほうが便利である(xxx)。この配置の問題は、xv6が物理メモリを2GB以上作成することができないことである。いくつかのデバイスはメモリマップドI/Oを利用しており、物理アドレスが0xFE000000から開始するものがある。従って、xv6のページテーブルは、その場所への直接のマッピングを含んでいる。xv6はKERNBASEよりも上位のPTEに対してPTE_Uフラグを設定せず、カーネルだけがそれを利用することができるのである。
全てのプロセスが、ユーザメモリとカーネル全体を参照するためのページテーブルを保持することによって、システムコールや割り込みが発生したことによるユーザコードからカーネルコードへの変換が便利になる: このようなスイッチでは、ページテーブルのスイッチが必要無くなる。カーネルの殆どの部分では、自身のページテーブルは不要である;常にいくつかのプロセスのページテーブルを借りるている。
まとめると、xv6は各プロセスが自身のメモリしか利用していないことを保証しており、各プロセスのメモリ空間は仮想アドレスの0番地から連続して取られている。xv6は仮想アドレスPTEのPTE_Uビットを設定することで、プロセスが自分自身のメモリしか参照できないようにする。次に、ページテーブルの能力を用いて後続の仮想アドレスを、プロセスに割り当てられた物理ページのどこへども変換する。(xxx)

#コード例: アドレス空間の作成
kvmalloc(1857行目)はカーネルが実行するためのKERNBASEよりも上位のマッピングを実行するためのページテーブルの作成とスイッチを行う。殆どの処理はsetup-kvmで実行される(1837行目)。最初にエモリのページを確保し、ページディレクトリを保持する。次にmappagesを呼び出し、カーネルが必要な、kmap(1828行目)配列に記述されている、カーネルに必要な変換処理を設定する。変換には、カーネルのいいとデータが含まれており、物理メモリは最大でPHYSTOPまでである。メモリ幅は実際にはI/Oデバイスのメモリ幅である。setup-kvmはユーザメモリ向けのマッピングは一切設定しない; これは後で設定される。
mappages(1779行目)は仮想アドレスの範囲を該当する物理アドレスの範囲までのマッピングをページテーブルに設定する。この範囲の各仮想アドレスは、ページのインターバルによって別々に設定される。マッピングされた各仮想アドレスのために、mappagesはwalkpgdirを呼び出して、そのアドレスのためのPTEのアドレスを探索する。次にPTEを初期化して関係のあるページテーブルの番号を設定し、所望のパーミッション(PTE_WやPTE_Uなど)を設定し、PTE_Pを設定することでPTEが有効であることを設定する(1791行目)。
walkpgdir(1754行目)は、仮想アドレスのためのPTEを探索するというx86の動作を模倣している(図2-1を参照のこと)。warkpgdirはページディレクトリのエントリを探索するために最大で10ビットの仮想アドレスを利用する(1759行目)。もしページディレクトリのエントリが存在しなければ、必要なページテーブルは割り当てられていないということになる; もしallocの引数が設定されていれば、walkpgdirはそれを割り当て、ページディレクトリの物理アドレスを設定する。最後に、仮想アドレスの次の10ビットを利用してページテーブルページ内のPTEのアドレスを探索する(1772行目)。

# 物理メモリの割り当て
カーネルはページテーブルやプロセスのユーザメモリ、カーネルスタック、パイプバッファのために、フリーな物理メモリを割り当てる必要がある。
xv6はカーネルの最後とPHYSTOPの間で実行時に割り当てを行うたえに、物理メモリを利用する。その歳に4096バイトのページの割り当てや解放を実行する。この歳に、フリーなページ自身をリンクリストに繋いで記録しておく; ページを解放すると、このリストにフリーとなったページが挿入される。
ここで、ブートストラップの問題が発生する:全ての物理メモリはアロケータがフリーリストを初期化した順番にマップが作成されなければならないが、このようなマッピングを含むページテーブルには、ページテーブルのページを割り当てる処理も発生する。xv6はこの問題を、エントリに洗剤している最中は異なるページアロケータを利用することで解決している。エントリはカーネルのデータセグメントの後ろに割り当てられている。このアロケータはメモリの解放はサポートしておらず、entrypgdir中の4MBまでのマッピングに制限されている。しかし最初のカーネルのページテーブルを割り当てるのには、これで十分である。
