第3章 トラップ、割り込み、ドライバ
==================================

プロセスを実行している際、CPUは通常のプロセッサループを実行している; 命令を読み込み、プログラムカウンタを進め、命令を実行し続けている。
しかし、次のプログラムを実行する代わりに、ユーザプログラムからのカーネルへの遷移の制御要求イベントが発生することがある。
このイベントには、注目をしてもらうためのデバイスからのシグナル要求や、ユーザプログラムの異常(例えば、PTEの存在しない仮想アドレスの参照)、ユーザプログラムのシステムコールによるカーネルへのサービスの要求などが含まれる。
これらのイベントをうまく取り扱うためには、以下の3つの困難を解消する必要がある:
1) カーネルはプロセッサをユーザモードからカーネルモードに遷移させる(そして最終的には戻ってくる)
2) カーネルとデバイスは、デバイスが並列動作を制御する
3) カーネルはデバイスのインタフェースを理解しなければならない。
上記の3つの問題をうまく取り扱うために、ハードウェアの深い理解と慎重なプログラミングをした結果、不透明なカーネルコードになってしまう可能性もある。
本書うでは、xv6が、これらの問題をどのようにして取り組んでいるのかについて説明する。

# システムコール、例外、割り込み

前章の最後に見たように、ユーザプログラムによるシステムコールであ、オペレーティングシステムにサービスを要求する。
「例外」という用語は、プログラムの異常な動作により発生する割り込みのことを指す。
プログラムの異常な動作の例として、ゼロによる除算、PTEに存在しないアドレスへのメモリアクセスなどがある。
「割り込み」という用語は、ハードウェアデバイスにより発生するシグナルのことを指し、オペレーティングシステムによって何か処理をしなければならなに。
例えば、クロックチップは割り込みを100ミリ秒に1回発生させることで、カーネルが時分割共有を実現できるようにしている。
他の例として、ディスクが読み込み動作を行うと、割り込みを発生させることでオペレーティングシステムに対して、読み込んだブロックを取り込む準備ができたことを通知する。

プロセスの代わりに、カーネルは全ての割り込みを処理する。
何故ならば、殆どのケースにおいて、カーネルのみ権限と状態を持っているからである。
例えば、クロックの割り込みに反応してプロセスを切り替える時分割を実現するとき、互いに協調動作することのできないプロセスをプロセッサにロードするためには、カーネルを起動しなければならない。

全ての3つのケースにおいて、オペレーティングシステムのデザインはこれらが発生する準備を整えておく必要がある。
システムは次回の回復に備えてプロセッサのレジスタを退避しておかなけばならない。
システムはカーネル上で実行の準備をしなければならない。
システムはカーネルが実行を開始するための場所を選択しなければならない。
カーネルはシステムコールの引数など、イベントについての情報を入手できなければならない。
これらは全て、セキュアな状態で実行される; システムはユーザプロセスとカーネルの独立性を維持していなければならない。

これらの目標を達成するために、オペレーティングシステムはハードウェアがどのようにして、システムコール、例外、割り込みを処理するのかについて理解していなければならない。
殆どのプロセッサでは、これらの3つのイベントは単一のハードウェア機構によって処理される。
例えば、x86では、プログラムはint命令を実行して割り込みを発生させ、システムコールを起動する。
同様に、例外も割り込みを発生させる。
従って、もしオペレーティングシステムが割り込みを処理することができるのであれば、オペレーティングシステムはシステムコールや例外も処理することができる。

基本的な考え方は以下の通りである。
割り込みによって通常のプロセッサループが停止し、「割り込みハンドラ」と呼ばれる新しいプログラムのシーケンスが実行される。
割り込みハンドラを実行する前に、プロセッサは、自信のレジスタを退避し、割り込み処理から復帰するときにそのレジスタ値を書き戻せるようにする。
割り込みハンドラへ遷移すること、割り込みハンドラから戻ってくることは、プロセッサがユーザモードとカーネルモードを行き来することを意味する。

用語について: x86の公式な用語は割り込み(interrupt)であるが、xv6は「トラップ」とも呼ぶ。
これはPDP11/40で使われていた言葉であり、伝統的なUnixの用語であるためである。
本章ではトラップと割り込みは同じ意味であるとするが、トラップは現在プロセッサ上で動作しているプロセスによって発生させられるものであり(例えば、プロセスがシステムコールを発生させ、結果としてトラップを発生させる)、
割り込みは現在実行されているプロセスとは関係無く、デバイスによって発生させられるものである。
例えば、ディスクはあるプロセスによって要求されたブロックの読み込みを完了すると、割り込みを発生させる。
割り込みの特徴により、割り込みはトラップについて考えるようりもより難しいものとなる。
なぜならば 、割り込みは他の動作と並列に派生するからである。
同一のハードウェア機構でもって、ユーザモードとカーネルモードをセキュアにセキュアに遷移する方法については、次節で議論する。

# x86の保護

x86は4つの保護レベルを持っている。0が最も保護レベルが強く、3が最も保護レベルが弱い。
実際には、殆どのオペレーティングシステムは、0か3の2つの保護レベルしか使用しない。0がカーネルモード、3がユーザモードに相当する。
x86において、実行している命令の現在の保護レベルは%csレジスタのCPLフィールドに保存されている。

x86では、割り込みハンドラは割り込みディスクリプタテーブル(IDT)によって定義されている。
IDTは256エントリであり、該当する割り込みを処理する際に%cと%eipが利用される。

x86のシステムコールを生成するために、プログラムはint n命令を実行する。nはIDTのインデックスである。
int命令は次の処理を行う:

* IDTからn番目のディスクリプタをフェッチする。nはint命令のオペランドである。
* %csのCPLフィールドをチェックし、ディスクリプタの保護レベルであるDPL以下であることを確認する。
* ターゲットセグメントセレクタがPL<CPLであった場合にのみ、CPUの内部レジスタである%espと%ssを保存するが、
* %ssと%espをタスクセグメントディスクリプタからロードする。
* %ssをプッシュする。
* %espをプッシュする
* %eflagsをプッシュする
* %csをプッシュする
* %eipをプッシュする
* %eflagsのいくつかのフィールドをクリアする
* %csと%eipにディスクリプタの値をセットする

int命令は複雑な命令であり、これら全ての動作が必要かどうか疑問に思うもしれない。
CPL<=DPLであることのチェックにより、カーネルがシステムの他の権限レベルについて禁止している。
例えば、ユーザプログラムがint命令の実行に成功すると、DPLは3になっている。
もしユーザプログラムが適切な権限を持っておらず、int命令は、結果としてint 13となる。int 13は一般的な保護の失敗を意味する割り込みである。
他の例として、ユーザが適切なスタックを準備することができず、int命令がユーザスタックを準備することができないことにより、ハードウェアがタスクセグメントによって指定されるスタック、つまりカーネルのスタック利用した場合にも、同様の状態が発生する。

図3-1はint命令が完了した時のスタックの状態を示している。この状態では、権限レベルの変更も完了している(ディスクリプタの権限レベルはCPLよりも小さい)。
もしint命令が権限レベルの変更を要求しなかった場合、x86は%ssと%espの保存をしない。
どちらのケースでも、int命令を実行した後は、%eipはディスクリプタテーブルによって指定されたアドレスを指しており、命令のアドレスはint nによって指定されるハンドラの最初の命令を指している。
これらのハンドラを実装するのがオペレーティングシステムの役割であり、以降ではxv6がどのように実行しているのかについて見る。

オペレーティングシステムはiret命令を利用してint命令から戻ってくることができる。
iret命令はint命令によってスタックに保存されていたデータを回復し、%eipに保存されていたアドレスから実行を再開する。

# 最初のシステムコール
第1章では、initcode.Sがシステムコールを呼ぶところまでを見た。
そのコードをもう一度見てみよう(8213行目)。
execを呼び出すのに必要な引数がプロセスのスタックにプッシュされ、システムコールの番号が%eaxにセットされる。
システムコールの番号はsyscalls配列のエントリ番号に一致し、syscallsエントリには関数ポインタが格納されている。
int命令がユーザモードからカーネルモードに切り替わり、適切なカーネル関数(例えば、sys_execなど)を実行するためにsys_execの引数を適切に探索することができるようにしなければならない。
次節から、xv6がどのようにしてこれらのシステムコールを呼び出しているのか、そして同様のコードをどのようにして割り込みと例外処理に再利用しているのかについて見ていく。
