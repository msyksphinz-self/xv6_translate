第3章 トラップ、割り込み、ドライバ
==================================

プロセスを実行している際、CPUは通常のプロセッサループを実行している; 命令を読み込み、プログラムカウンタを進め、命令を実行し続けている。
しかし、次のプログラムを実行する代わりに、ユーザプログラムからのカーネルへの遷移の制御要求イベントが発生することがある。
このイベントには、注目をしてもらうためのデバイスからのシグナル要求や、ユーザプログラムの異常(例えば、PTEの存在しない仮想アドレスの参照)、ユーザプログラムのシステムコールによるカーネルへのサービスの要求などが含まれる。
これらのイベントをうまく取り扱うためには、以下の3つの困難を解消する必要がある:
1) カーネルはプロセッサをユーザモードからカーネルモードに遷移させる(そして最終的には戻ってくる)
2) カーネルとデバイスは、デバイスが並列動作を制御する
3) カーネルはデバイスのインタフェースを理解しなければならない。
上記の3つの問題をうまく取り扱うために、ハードウェアの深い理解と慎重なプログラミングをした結果、不透明なカーネルコードになってしまう可能性もある。
本書うでは、xv6が、これらの問題をどのようにして取り組んでいるのかについて説明する。

# システムコール、例外、割り込み

前章の最後に見たように、ユーザプログラムによるシステムコールであ、オペレーティングシステムにサービスを要求する。
「例外」という用語は、プログラムの異常な動作により発生する割り込みのことを指す。
プログラムの異常な動作の例として、ゼロによる除算、PTEに存在しないアドレスへのメモリアクセスなどがある。
「割り込み」という用語は、ハードウェアデバイスにより発生するシグナルのことを指し、オペレーティングシステムによって何か処理をしなければならなに。
例えば、クロックチップは割り込みを100ミリ秒に1回発生させることで、カーネルが時分割共有を実現できるようにしている。
他の例として、ディスクが読み込み動作を行うと、割り込みを発生させることでオペレーティングシステムに対して、読み込んだブロックを取り込む準備ができたことを通知する。

プロセスの代わりに、カーネルは全ての割り込みを処理する。
何故ならば、殆どのケースにおいて、カーネルのみ権限と状態を持っているからである。
例えば、クロックの割り込みに反応してプロセスを切り替える時分割を実現するとき、互いに協調動作することのできないプロセスをプロセッサにロードするためには、カーネルを起動しなければならない。

全ての3つのケースにおいて、オペレーティングシステムのデザインはこれらが発生する準備を整えておく必要がある。
システムは次回の回復に備えてプロセッサのレジスタを退避しておかなけばならない。
システムはカーネル上で実行の準備をしなければならない。
システムはカーネルが実行を開始するための場所を選択しなければならない。
カーネルはシステムコールの引数など、イベントについての情報を入手できなければならない。
これらは全て、セキュアな状態で実行される; システムはユーザプロセスとカーネルの独立性を維持していなければならない。

これらの目標を達成するために、オペレーティングシステムはハードウェアがどのようにして、システムコール、例外、割り込みを処理するのかについて理解していなければならない。
殆どのプロセッサでは、これらの3つのイベントは単一のハードウェア機構によって処理される。
例えば、x86では、プログラムはint命令を実行して割り込みを発生させ、システムコールを起動する。
同様に、例外も割り込みを発生させる。
従って、もしオペレーティングシステムが割り込みを処理することができるのであれば、オペレーティングシステムはシステムコールや例外も処理することができる。

基本的な考え方は以下の通りである。
割り込みによって通常のプロセッサループが停止し、「割り込みハンドラ」と呼ばれる新しいプログラムのシーケンスが実行される。
割り込みハンドラを実行する前に、プロセッサは、自信のレジスタを退避し、割り込み処理から復帰するときにそのレジスタ値を書き戻せるようにする。
割り込みハンドラへ遷移すること、割り込みハンドラから戻ってくることは、プロセッサがユーザモードとカーネルモードを行き来することを意味する。

用語について: x86の公式な用語は割り込み(interrupt)であるが、xv6は「トラップ」とも呼ぶ。
これはPDP11/40で使われていた言葉であり、伝統的なUnixの用語であるためである。
本章ではトラップと割り込みは同じ意味であるとするが、トラップは現在プロセッサ上で動作しているプロセスによって発生させられるものであり(例えば、プロセスがシステムコールを発生させ、結果としてトラップを発生させる)、
割り込みは現在実行されているプロセスとは関係無く、デバイスによって発生させられるものである。
例えば、ディスクはあるプロセスによって要求されたブロックの読み込みを完了すると、割り込みを発生させる。
割り込みの特徴により、割り込みはトラップについて考えるようりもより難しいものとなる。
なぜならば 、割り込みは他の動作と並列に派生するからである。
同一のハードウェア機構でもって、ユーザモードとカーネルモードをセキュアにセキュアに遷移する方法については、次節で議論する。

# x86の保護

x86は4つの保護レベルを持っている。0が最も保護レベルが強く、3が最も保護レベルが弱い。
実際には、殆どのオペレーティングシステムは、0か3の2つの保護レベルしか使用しない。0がカーネルモード、3がユーザモードに相当する。
x86において、実行している命令の現在の保護レベルは%csレジスタのCPLフィールドに保存されている。

x86では、割り込みハンドラは割り込みディスクリプタテーブル(IDT)によって定義されている。
IDTは256エントリであり、該当する割り込みを処理する際に%cと%eipが利用される。

x86のシステムコールを生成するために、プログラムはint n命令を実行する。nはIDTのインデックスである。
int命令は次の処理を行う:

* IDTからn番目のディスクリプタをフェッチする。nはint命令のオペランドである。
* %csのCPLフィールドをチェックし、ディスクリプタの保護レベルであるDPL以下であることを確認する。
* ターゲットセグメントセレクタがPL<CPLであった場合にのみ、CPUの内部レジスタである%espと%ssを保存するが、
* %ssと%espをタスクセグメントディスクリプタからロードする。
* %ssをプッシュする。
* %espをプッシュする
* %eflagsをプッシュする
* %csをプッシュする
* %eipをプッシュする
* %eflagsのいくつかのフィールドをクリアする
* %csと%eipにディスクリプタの値をセットする

int命令は複雑な命令であり、これら全ての動作が必要かどうか疑問に思うもしれない。
CPL<=DPLであることのチェックにより、カーネルがシステムの他の権限レベルについて禁止している。
例えば、ユーザプログラムがint命令の実行に成功すると、DPLは3になっている。
もしユーザプログラムが適切な権限を持っておらず、int命令は、結果としてint 13となる。int 13は一般的な保護の失敗を意味する割り込みである。
他の例として、ユーザが適切なスタックを準備することができず、int命令がユーザスタックを準備することができないことにより、ハードウェアがタスクセグメントによって指定されるスタック、つまりカーネルのスタック利用した場合にも、同様の状態が発生する。

図3-1はint命令が完了した時のスタックの状態を示している。この状態では、権限レベルの変更も完了している(ディスクリプタの権限レベルはCPLよりも小さい)。
もしint命令が権限レベルの変更を要求しなかった場合、x86は%ssと%espの保存をしない。
どちらのケースでも、int命令を実行した後は、%eipはディスクリプタテーブルによって指定されたアドレスを指しており、命令のアドレスはint nによって指定されるハンドラの最初の命令を指している。
これらのハンドラを実装するのがオペレーティングシステムの役割であり、以降ではxv6がどのように実行しているのかについて見る。

オペレーティングシステムはiret命令を利用してint命令から戻ってくることができる。
iret命令はint命令によってスタックに保存されていたデータを回復し、%eipに保存されていたアドレスから実行を再開する。

# 最初のシステムコール
第1章では、initcode.Sがシステムコールを呼ぶところまでを見た。
そのコードをもう一度見てみよう(8213行目)。
execを呼び出すのに必要な引数がプロセスのスタックにプッシュされ、システムコールの番号が%eaxにセットされる。
システムコールの番号はsyscalls配列のエントリ番号に一致し、syscallsエントリには関数ポインタが格納されている。
int命令がユーザモードからカーネルモードに切り替わり、適切なカーネル関数(例えば、sys_execなど)を実行するためにsys_execの引数を適切に探索することができるようにしなければならない。
次節から、xv6がどのようにしてこれらのシステムコールを呼び出しているのか、そして同様のコードをどのようにして割り込みと例外処理に再利用しているのかについて見ていく。

# コード例: アセンブリ言語で記述されたトラップハンドラ

xv6はint命令が実行され、プロセッサがトラップを発生せた場合に、そのトラップを正しく処理できるようにx86のハードウェアを準備しておく必要がある。
x86は256種類の異なる割り込みを処理することができる。
割り込み0から31はソフトウェアによる例外であり、ゼロ除算や、不正メモリアクセスなどが定義されている。
xv6は32から32までの領域にハードウェア割り込みを割り当てており、64をシステムコールの割り込みに割り当てている。

tvinit(3317行目)は、mainから呼び出され、テーブルidtの256エントリの準備を行う。
割り込みの種類がiである場合、vectors[i]に格納されたアドレスのコードによって割り込みが処理される。
各エントリポイントは異なっており、それはx86がトラップ番号を割り込みハンドラに通知しないことによる。
256種類の異なるハンドラを呼び出すことが、256種類のケースを識別する唯一の手段である。

tvinitはユーザシステムコールトラップであるT_SYSCALL特別な処理として扱う; この「トラップ」の型のゲートであり、2番目の引数として1を渡すというように規定しているxxx。
トラップゲートはFLフラグをクリアせず、システムコールハンドラ中で他の割り込みが発生することを許可する。

カーネルはシステムコールゲートの優先度をDPL_USERに設定し、ユーザプログラムがint命令により、明示的にトラップを発生させることができるかを指定する。
xv6はプロセスがint命令による割り込み(例えば、デバイス割り込み)を発生させることを許さない； もしそれらが割り込みを発生させようとした場合、一般保護例外が発生し、ベクトル13に飛ぶ。

ユーザモードからカーネルモードに権限が切り替わった場合、スタックを有効に保つために、カーネルはユーザプロセスのスタックを利用すべきではない。
ユーザプロセスは悪意のあるものである可能性があり、%espにプロセスの利用していないユーザメモリの一部を設定される可能性がある。
xv6は、x86のハードウェアをプログラムし、タスクセグメントディスクリプタを設定し、ハードウェアがスタックセグメントセレクタをロードし、新しい値を%espに設定する際に、スタックをスイッチする。
関数switchuvm(1873行目)はユーザプロセス中に存在するカーネルスタックのトップアドレスをタスクセグメントディスクリプタに設定する。

トラップが発生すると、プロセッサのハードウェアは以下のように動作する。
もしプロセッサがユーザモード中で実行していると、%espと%ssをタスクセグメントディスクリプタからロードし、古い%ssと%espを新しいスタック上にプッシュする。
もしプロセッサがカーネルモードで実行されていたら、上記の動作は発生しない。
次に、プロセッサは%eflags,%cs,%eipレジスタをプッシュする。
いくつかのトラップのために、プロセッサはエラーワードもプッシュする。
プロセッサは%eipと%csを、関連するIDTエントリからロードする。

xv6はPerlスクリプト(3200行目)を用いて、IDTのエントリが指すべきエントリポイントを生成する。
各エントリは、プロセッサがエントリを挿入しなかった場合、エントリに割り込み番号を挿入し、alltraps関数にジャンプする。(xxx)

alltraps(3254行目)は続けてプロセッサのレジスタを保存する; %ds, %es, %fs, %gsおよび汎用レジスタをプッシュする(3255-3260行目)。
この努力により、カーネルスタックには、今やstruct trapframe(0602行目)が入った形になっており、トラップ発生時のプロセッサのレジスタ値が挿入されている(図3-2を参照)。
プロセッサは%ss, %eps, %eflags, %cs, %eipをプッシュする。プロセッサもしくはトラップベクタがエラー番号をプッシュし、alltrapは残りをプッシュする。
trapframeはプロセッサのレジスタをユーザモードに戻すための全ての情報が挿入されており、カーネルが現在のプロセスに戻ってきたときにユーザモードに正しく戻れるようにしている。
これにより、プロセッサはトラップが始まっても、正確に実行し続けることができるのである。
第2章で紹介したように、userinitはトラップフレームを作成するために、手動で構築している(図1-4)。

最初のシステムコールの場合には、保存された%eipはint命令が実行された直後のアドレスを指している。
%csはユーザコードのセグメントセレクタである。
l%eflagsはint命令を実行した際のeflagsレジスタの値である。
汎用レジスタを保存するルーチンの中で、alltrapsはシステムコール番号を保持している%eaxも保存を行い、システムコールの番号を後で検査できるようになっている。

現在、ユーザモード中のプロセッサのレジスタは保存され、alltrapsはプロセッサがカーネルのCコードを実行する準備を整えた。
プロセッサはハンドラに入る前に%csにセレクタを設定し、%ssを設定する； alltrapsは%dsと%esを設定する(3263-3265行目)。
さらに%fsと%gsを設定し、CPU毎のデータセセグントのSEG_KCPUを指すようにする(3266-3268行目)。

セグメントが正しく設定されると、alltrapsはCのトップハンドラであるtrapを呼び出すことができるようになる。
これは、今現在構築されたトラップフレームを指している%espをプッシュし、trap命令の引数となるようにスタックの上に載せる(3272行目)。
その後、alltrapを呼び出す(3271行目)。
trapから帰ってくると、alltrapはスタック上の引数をポップし、スタックポインタを加算する(3273行目)。
そしてラベルtrapretから始まるコードを実行し始める。
このコードを、最初のユーザプロセスが、ユーザ空間を終了するために実行するところを見た。
同様のシーケンスが発生する: トラップフレームを取り出し、ユーザモードレジスタに挿入し、iretによりユーザ空間に戻ってくる。
ユーザモード中に発生したトラップについて議論してきたが、trapはカーネルが実行している最中にも発生し得る。
ハードウェアがスタックをスイッチしない場合は、スタックポインタを保存し、スタックセグメントを保存する; そうでない場合には、同様のステップを実行し、ユーザモードからトラップを処理し、xv6と同様のトラップ処理コードを実行する。
iretが最後にカーネルモードの%csを回復し、プロセッサはカーネルモードで動作し続ける。

# コード例: Cのトラップハンドラ
前節では、各ハンドラがトラップフレームを設定し、Cの関数であるtrapを呼び出した。
trap(3351行目)はハードウェアトラップ番号tf->trappnoを読み込み、このトラップが何故発生したか、そして何をすべきかを決定する。
トラップがT_SYSCALLであった場合、trapはシステムコールハンドラであるsyscallを呼び出す。
これらについては、第5章で、proc->killedを調査するときに再び見る。

システムコールをチェックした後は、トラップはハードウェア割り込みをチェックする(これについては、移行で議論する)。
予想し得るハードウェアデバイスに加えて、トラップは予想外のハードウェアの割り込みによって、異常な割り込みが発生してしまうことがある。

トラップがシステムコールではなく、ハードウェアデバイスにより注意を払うべきものでもなかった場合、trapはこのトラップはトラップが実行される前にコードによって発生した異常な動作であるとみなす(例えば、ゼロ除算など)。
もしこのようなトラップがユーザプロセスによって発生した場合、xv6は詳細をプリントし、cp->killedを設定しユーザプロセスをクリーンアップする。
クリーンアップの動作については、第5章で詳細をチェックする。

もしカーネルが実行中であった場合には、これはカーネルのバグである; trapはこの異常動作について詳細をプリントし、panicを呼び出す。

# コード例: システムコール
システムコール向けには、trapはsyscall(3625行目)を呼びだす。
syscallは%eaxに含まれているシステムコールの番号をトラップフレームからロードし、システムコールのテーブルを指すようにする。
最初のシステムコールでは、%eaxはSYS_exec(3457行目)が入っており、syscallはSYS_execのシステムコールテーブルのエントリを読み出し、sys_execを実行する。

syscallはシステムコール関数の戻り値を%eaxに保存する。
trapがユーザ空間に戻ってきたときに、この戻り値はcp->tfからマシンのレジスタに戻される。
従って、execが戻ってくると、システムコールのハンドラの値が返されることになる。
システムコールは、伝統的に、エラーが発生すると負の値を返すようにしており、正の値だと成功を示す。
もしシステムコールの番号が不正であれば、syscallはエラーを表示し、-1を返す。
移行の章では、いくつかのシステムコールの実装について中身をチェックしていく。
本章では、システムコールのメカニズムについてを取り扱うことにする。
ここでは、もうひとつシステムコールの呼び方について説明しておく: システムコールの引数の設定である。
ヘルパー関数のargint, argptr, argstrはn番目のシステムコールを、それぞれ整数、ポインタ、文字列として探索する。
argintはn番目の引数の位置を特定するために、ユーザ空間の%espレジスタを利用する: l%espはシステムコールスタブの戻りアドレスを指している。
引数はその上に配置されており、%esp+4である。
従って、n番目の引数は%esp+4+4*nの場所に存在する。

argintはfetchintを呼び出し、ユーザメモリからそのアドレス中のデータを読み出し、\*ipに書き込む。
fetchintはユーザとカーネルが同一のページテーブルを共有するために、アドレスを単純にポインタにキャストするが、カーネルはユーザによって示されたそのポインタがユーザのアドレス空間に含まれているかどうかをチェックしなければならない。
カーネルはページテーブルのハードウェアを設定し、プロセスがローカルのプライベートメモリの外にアクセスできないように設定する: もしユーザプログラムがp->szのアドレス以上の場所を参照しようとすると、プロセッサはセグメンテーションフォルトを発生させ、これまでに見てきたように、プロセスを殺す処理に入る。
これまでで、カーネルはユーザが渡してきた任意のアドレスの値を取得することができるようになるため、カーネルは実行時にそのアドレスがp->szよりも低い場所であることをチェックしなければならない。

argptrはargintと同様の目的で利用される: argptrはn番目のシステムコールの引数を解釈する。
argptrはargintを呼び出し、まずは引数を整数として読み出す。引数が整数であるかをチェックし、フェッチした整数がユーザポインタであるかどうかをチェックし、確かにアドレス空間のユーザ領域に存在することをチェックする。
この2つのチェックはargptrを呼び出している最中に実行されることに注意する。
まず、ユーザスタックポインタが引数をフェッチしている最中にチェックされる。
次に、その引数自身がユーザ空間へのポインタであった場合についてチェックされる。

argstrはシステムコールの引数トリオの中の最後である。
argstrはn番目の引数をポインタとして受け取る。
このかんすう はポインタがNULLで終わる文字列であることを保証し、完全な文字列がアドレス空間のユーザ領域の中に存在していることをチェックする。

システムコールの実装(例えば、sysproc.cやsysfile.c)は典型的なラッパである: これらの関数は引数をargint, argptr, argstrを用いてチェックし、実際のシステムコールの実装を呼び出す。
第2章では、sys_execは引数を入手するために実際にこれらの関数を利用している。
