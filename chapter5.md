第5章 スケジューリング
==================

どのようなオペレーティングシステムも、コンピュータが持っているプロセッサの数以上のプロセスを実行し、従ってプロセス間で時分割共有することが必要になる。
理想的には、ユーザプロセスからはこの共有は見えないようにするべきである。
共通のアプローチとしては、各プロセスが個々に仮想マシンを保持しているように見せ掛け、オペレーティングシステムが複数の仮想マシンを単一のプロセッサで時分割共有して実行することである。
本性ではxv6がどのようにして複数のプロセスをプロセッサ上で実行しているのかについて説明する。

# 多重化

xv6は各プロセッサがあるプロセスから他のプロセスに切り替えることで多重化を行うが、これには2つの状態がある。
最初に、xv6は、あるプロセスがデバイスやパイプI/Oの完了を待つために待ち状態になると、sleepとwakeupの2つのメカニズムにより切り替えを行うか、子供が終了するのを待つか、sleepシステムコールによって終了するのを待つ。
次に、xv6がユーザ命令を実行中に、定期的に強制的に切り替えを行う。
この多重化により、各プロセスは自分のCPUを持っているように見えるが、xv6がメモリアロケータとハードウェアページテーブルにより各プロセスの固有のメモリを持っているように見せ掛けているだけである。

多重化を実装するには、いくつか困難な点がある。
最初に、あるプロセスからどのようにして別のプロセスに切り替えるのか？
xv6はコンテキストスイッチングの標準的なメカニズムを利用している; しかしアイデアはシンプルで、実装はシステムにおいて最も不透明である。
2番目に、どのようにして透過的なコンテキストスイッチングを実現するのか？
xv6は標準的なタイマ割り込みハンドラによりコンテキストスイッチを駆動している。
3番目に、多くのCPUはプロセスを同時に切り替えており、従ってレースコンディションを避けるためにロックの機構も考える必要がある。
4番目に、プロセスが終了したときに、そのメモリと資源を開放しなければならないが、しかしそれを自分自身では実行できない。
何故ならば、(例えば)自分が利用しているのに自分のカーネルスタックを開放することはできない。
xv6はこの問題をなるべくシンプルな方法で解決しようとしているが、結果として得られるコードはトリッキーである。

xv6はプロセスが自分自身を調整することのできる方法を提供しなければならない。
例えば、親プロセスはその子プロセスが終了するまで待つか、他のプロセスがパイプへの書き込みを行うのを待たなければならない。
プロセスが、所望のイベントが発生しているかチェックするためにCPUを無駄に利用するよりも、xv6はCPUの利用を諦めてイベントが発生するまでは眠っておき、他のプロセスが最初のプロセスを起動したほうが良い。
イベントの通知を読み落とすことを避けるために、レースコンディションを避けるためのケアが必要になる。
この問題と解答の例として、本章ではパイプの実装について取り扱う。
